<!DOCTYPE html>
<html>

<head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>cmd: Go Coverage Report</title>
        <style>
                body {
                        background: black;
                        color: rgb(80, 80, 80);
                }

                body,
                pre,
                #legend span {
                        font-family: Menlo, monospace;
                        font-weight: bold;
                }

                #topbar {
                        background: black;
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        height: 42px;
                        border-bottom: 1px solid rgb(80, 80, 80);
                }

                #content {
                        margin-top: 50px;
                }

                #nav,
                #legend {
                        float: left;
                        margin-left: 10px;
                }

                #legend {
                        margin-top: 12px;
                }

                #nav {
                        margin-top: 10px;
                }

                #legend span {
                        margin: 0 5px;
                }

                .cov0 {
                        color: rgb(192, 0, 0)
                }

                .cov1 {
                        color: rgb(128, 128, 128)
                }

                .cov2 {
                        color: rgb(116, 140, 131)
                }

                .cov3 {
                        color: rgb(104, 152, 134)
                }

                .cov4 {
                        color: rgb(92, 164, 137)
                }

                .cov5 {
                        color: rgb(80, 176, 140)
                }

                .cov6 {
                        color: rgb(68, 188, 143)
                }

                .cov7 {
                        color: rgb(56, 200, 146)
                }

                .cov8 {
                        color: rgb(44, 212, 149)
                }

                .cov9 {
                        color: rgb(32, 224, 152)
                }

                .cov10 {
                        color: rgb(20, 236, 155)
                }
        </style>
</head>

<body>
        <div id="topbar">
                <div id="nav">
                        <select id="files">

                                <option value="file0">robot_scheduler/cmd/main.go (0.0%)</option>

                                <option value="file1">robot_scheduler/docs/docs.go (0.0%)</option>

                                <option value="file2">robot_scheduler/internal/api/handler/base_handler.go (0.0%)
                                </option>

                                <option value="file3">robot_scheduler/internal/api/handler/device.go (0.0%)</option>

                                <option value="file4">robot_scheduler/internal/api/handler/operation.go (0.0%)</option>

                                <option value="file5">robot_scheduler/internal/api/handler/pcd_handler.go (0.0%)
                                </option>

                                <option value="file6">robot_scheduler/internal/api/handler/semantic.go (0.0%)</option>

                                <option value="file7">robot_scheduler/internal/api/handler/task.go (0.0%)</option>

                                <option value="file8">robot_scheduler/internal/api/handler/user_handler.go (0.0%)
                                </option>

                                <option value="file9">robot_scheduler/internal/api/middleware/middleware.go (0.0%)
                                </option>

                                <option value="file10">robot_scheduler/internal/api/router/router.go (0.0%)</option>

                                <option value="file11">robot_scheduler/internal/api/server.go (0.0%)</option>

                                <option value="file12">robot_scheduler/internal/config/config.go (0.0%)</option>

                                <option value="file13">robot_scheduler/internal/dao/device.go (61.0%)</option>

                                <option value="file14">robot_scheduler/internal/dao/pcd_file.go (60.0%)</option>

                                <option value="file15">robot_scheduler/internal/dao/semantic.go (61.0%)</option>

                                <option value="file16">robot_scheduler/internal/dao/task.go (61.0%)</option>

                                <option value="file17">robot_scheduler/internal/dao/user.go (65.7%)</option>

                                <option value="file18">robot_scheduler/internal/dao/user_operation.go (61.0%)</option>

                                <option value="file19">robot_scheduler/internal/database/database.go (0.0%)</option>

                                <option value="file20">robot_scheduler/internal/logger/logger.go (0.0%)</option>

                                <option value="file21">robot_scheduler/internal/minio_client/minio.go (75.0%)</option>

                                <option value="file22">robot_scheduler/internal/model/dto/device.go (0.0%)</option>

                                <option value="file23">robot_scheduler/internal/model/dto/pcd_file.go (0.0%)</option>

                                <option value="file24">robot_scheduler/internal/model/dto/semantic.go (0.0%)</option>

                                <option value="file25">robot_scheduler/internal/model/dto/task.go (0.0%)</option>

                                <option value="file26">robot_scheduler/internal/model/dto/user.go (0.0%)</option>

                                <option value="file27">robot_scheduler/internal/model/dto/user_operation.go (0.0%)
                                </option>

                                <option value="file28">robot_scheduler/internal/model/entity/device.go (0.0%)</option>

                                <option value="file29">robot_scheduler/internal/model/entity/pcd_file.go (0.0%)</option>

                                <option value="file30">robot_scheduler/internal/model/entity/semantic_map.go (0.0%)
                                </option>

                                <option value="file31">robot_scheduler/internal/model/entity/task.go (0.0%)</option>

                                <option value="file32">robot_scheduler/internal/model/entity/user.go (0.0%)</option>

                                <option value="file33">robot_scheduler/internal/model/entity/user_operation.go (0.0%)
                                </option>

                                <option value="file34">robot_scheduler/internal/service/device.go (0.0%)</option>

                                <option value="file35">robot_scheduler/internal/service/pcd_file.go (0.0%)</option>

                                <option value="file36">robot_scheduler/internal/service/semantic.go (0.0%)</option>

                                <option value="file37">robot_scheduler/internal/service/task.go (0.0%)</option>

                                <option value="file38">robot_scheduler/internal/service/user.go (15.7%)</option>

                                <option value="file39">robot_scheduler/internal/service/user_operation.go (0.0%)
                                </option>

                                <option value="file40">robot_scheduler/internal/testutil/db.go (0.0%)</option>

                                <option value="file41">robot_scheduler/internal/testutil/fixtures.go (0.0%)</option>

                                <option value="file42">robot_scheduler/internal/testutil/mocks/mock_device_dao.go (0.0%)
                                </option>

                                <option value="file43">robot_scheduler/internal/testutil/mocks/mock_pcd_dao.go (0.0%)
                                </option>

                                <option value="file44">robot_scheduler/internal/testutil/mocks/mock_semantic_dao.go
                                        (0.0%)</option>

                                <option value="file45">robot_scheduler/internal/testutil/mocks/mock_task_dao.go (0.0%)
                                </option>

                                <option value="file46">robot_scheduler/internal/testutil/mocks/mock_user_dao.go (0.0%)
                                </option>

                                <option value="file47">
                                        robot_scheduler/internal/testutil/mocks/mock_user_operation_dao.go (0.0%)
                                </option>

                                <option value="file48">robot_scheduler/internal/utils/crypto.go (92.5%)</option>

                                <option value="file49">robot_scheduler/internal/utils/jwt.go (81.2%)</option>

                                <option value="file50">robot_scheduler/internal/utils/permissions.go (100.0%)</option>

                        </select>
                </div>
                <div id="legend">
                        <span>not tracked</span>

                        <span class="cov0">no coverage</span>
                        <span class="cov1">low coverage</span>
                        <span class="cov2">*</span>
                        <span class="cov3">*</span>
                        <span class="cov4">*</span>
                        <span class="cov5">*</span>
                        <span class="cov6">*</span>
                        <span class="cov7">*</span>
                        <span class="cov8">*</span>
                        <span class="cov9">*</span>
                        <span class="cov10">high coverage</span>

                </div>
        </div>
        <div id="content">

                <pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "robot_scheduler/internal/api"
        "robot_scheduler/internal/config"
        impl "robot_scheduler/internal/dao"
        "robot_scheduler/internal/database"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/minio_client"
        "robot_scheduler/internal/service"

        _ "robot_scheduler/docs"

        "go.uber.org/zap"
)

// @title 机器人调度系统 API
// @version 1.0
// @description 机器人调度系统后台管理接口
// @termsOfService http://swagger.io/terms/
// @host localhost:8080
// @BasePath /api/v1
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() <span class="cov0" title="0">{
        // 初始化配置
        cfgPath := "configs/config.yaml"
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                cfgPath = os.Args[1]
        }</span>

        <span class="cov0" title="0">if err := config.Init(cfgPath); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to init config: %v", err))</span>
        }

        <span class="cov0" title="0">cfg := config.Get()

        // 初始化日志
        if err := logger.Init(cfg.Log); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to init logger: %v", err))</span>
        }
        <span class="cov0" title="0">defer logger.Sync()

        logger.Info("starting robot scheduler",
                zap.String("version", cfg.App.Version),
                zap.String("mode", cfg.App.Mode),
        )

        // 初始化数据库
        if err := database.Init(cfg); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to init database", zap.Error(err))
        }</span>

        // 初始化超级管理员用户
        <span class="cov0" title="0">if err := initSuperAdmin(cfg); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to init superAdmin", zap.Error(err))
                // 不阻止程序启动，只记录错误
        }</span>

        // 初始化MinIO客户端
        <span class="cov0" title="0">if cfg.Minio != nil &amp;&amp; cfg.Minio.Enabled </span><span class="cov0" title="0">{
                if err := minio_client.Init(cfg.Minio); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to init minio", zap.Error(err))
                }</span>
        }

        // 初始化HTTP服务器
        <span class="cov0" title="0">server := api.NewServer(cfg)

        // 优雅关闭
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                logger.Info(fmt.Sprintf("server started on :%d", cfg.App.Port))
                if err := server.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Fatal("failed to start server", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">&lt;-quit
        logger.Info("shutting down server...")

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("server shutdown error", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("server exited")</span>
}

// initSuperAdmin 初始化超级管理员用户
func initSuperAdmin(cfg *config.Config) error <span class="cov0" title="0">{
        // 检查认证配置
        if cfg.Auth == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("auth config is nil")
        }</span>

        <span class="cov0" title="0">if cfg.Auth.DESKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DES key is not configured")
        }</span>

        // 创建用户服务
        <span class="cov0" title="0">userDAO := impl.NewUserDAO(database.DB)
        userService := service.NewUserService(userDAO)

        // 初始化超级管理员
        ctx := context.Background()
        return userService.InitSuperAdmin(ctx, cfg.Auth.DESKey)</span>
}
</pre>

                <pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "用户登录，返回JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "认证"
                ],
                "summary": "用户登录",
                "parameters": [
                    {
                        "description": "登录信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "401": {
                        "description": "用户名或密码错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "用户退出登录",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "认证"
                ],
                "summary": "用户退出",
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/devices": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "查询所有设备",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "设备管理"
                ],
                "summary": "查询设备列表",
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "创建新设备",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "设备管理"
                ],
                "summary": "创建设备",
                "parameters": [
                    {
                        "description": "设备信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.DeviceCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/devices/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "根据ID获取设备信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "设备管理"
                ],
                "summary": "获取设备",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "设备ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "设备不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "更新设备信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "设备管理"
                ],
                "summary": "更新设备",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "设备ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "更新信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.DeviceUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "设备不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "删除设备（软删除）",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "设备管理"
                ],
                "summary": "删除设备",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "设备ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/maps/pcd-files": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "查询所有点云地图",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "点云地图"
                ],
                "summary": "查询点云地图列表",
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "创建新点云地图",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "点云地图"
                ],
                "summary": "创建点云地图",
                "parameters": [
                    {
                        "description": "点云地图信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.PCDFileCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/maps/pcd-files/upload-token": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "返回 MinIO 预签名上传 URL",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "点云地图"
                ],
                "summary": "获取点云地图上传凭证",
                "parameters": [
                    {
                        "description": "上传文件信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.PCDFileUploadTokenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/maps/pcd-files/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "根据ID获取点云地图信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "点云地图"
                ],
                "summary": "获取点云地图",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "点云地图ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "点云地图不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "更新点云地图信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "点云地图"
                ],
                "summary": "更新点云地图",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "点云地图ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "更新信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.PCDFileUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "点云地图不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "删除点云地图（软删除）",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "点云地图"
                ],
                "summary": "删除点云地图",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "点云地图ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/maps/semantic-maps": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "查询所有语义地图",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "语义地图"
                ],
                "summary": "查询语义地图列表",
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "创建新语义地图",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "语义地图"
                ],
                "summary": "创建语义地图",
                "parameters": [
                    {
                        "description": "语义地图信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.SemanticMapCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/maps/semantic-maps/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "根据ID获取语义地图信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "语义地图"
                ],
                "summary": "获取语义地图",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "语义地图ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "语义地图不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "更新语义地图信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "语义地图"
                ],
                "summary": "更新语义地图",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "语义地图ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "更新信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.SemanticMapUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "语义地图不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "删除语义地图（软删除）",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "语义地图"
                ],
                "summary": "删除语义地图",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "语义地图ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/operations": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "查询所有操作记录",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "操作记录"
                ],
                "summary": "查询操作记录列表",
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/operations/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "根据ID获取操作记录信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "操作记录"
                ],
                "summary": "获取操作记录",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "操作记录ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "操作记录不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/tasks": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "查询所有任务",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "任务管理"
                ],
                "summary": "查询任务列表",
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "创建新任务",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "任务管理"
                ],
                "summary": "创建任务",
                "parameters": [
                    {
                        "description": "任务信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.TaskCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/tasks/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "根据ID获取任务信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "任务管理"
                ],
                "summary": "获取任务",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "任务ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "任务不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "更新任务信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "任务管理"
                ],
                "summary": "更新任务",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "任务ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "更新信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.TaskUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "任务不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "删除任务（软删除）",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "任务管理"
                ],
                "summary": "删除任务",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "任务ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "description": "查询所有用户",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "用户管理"
                ],
                "summary": "查询用户列表",
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "post": {
                "description": "创建新用户",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "用户管理"
                ],
                "summary": "创建用户",
                "parameters": [
                    {
                        "description": "用户信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.UserCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        },
        "/users/{id}": {
            "get": {
                "description": "根据ID获取用户信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "用户管理"
                ],
                "summary": "获取用户",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "用户不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "put": {
                "description": "更新用户信息",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "用户管理"
                ],
                "summary": "更新用户",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "更新信息",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/robot_scheduler_internal_model_dto.UserUpdateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "404": {
                        "description": "用户不存在",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            },
            "delete": {
                "description": "删除用户（软删除）",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "用户管理"
                ],
                "summary": "删除用户",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "用户ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "成功",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "400": {
                        "description": "参数错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    },
                    "500": {
                        "description": "服务器错误",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handler.Response"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "internal_api_handler.Response": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "data": {},
                "message": {
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.DeviceCreateRequest": {
            "type": "object",
            "required": [
                "company",
                "port",
                "type"
            ],
            "properties": {
                "company": {
                    "description": "设备厂商",
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.CompanyType"
                        }
                    ]
                },
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "ip": {
                    "description": "设备IP",
                    "type": "string"
                },
                "password": {
                    "description": "登录密码",
                    "type": "string"
                },
                "port": {
                    "description": "设备端口",
                    "type": "integer"
                },
                "type": {
                    "description": "设备类型",
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.DeviceType"
                        }
                    ]
                },
                "userName": {
                    "description": "登录用户名",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.DeviceUpdateRequest": {
            "type": "object",
            "properties": {
                "company": {
                    "description": "设备厂商",
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.CompanyType"
                        }
                    ]
                },
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "ip": {
                    "description": "设备IP",
                    "type": "string"
                },
                "password": {
                    "description": "登录密码",
                    "type": "string"
                },
                "port": {
                    "description": "设备端口",
                    "type": "integer"
                },
                "status": {
                    "description": "设备状态",
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.DeviceStatus"
                        }
                    ]
                },
                "type": {
                    "description": "设备类型",
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.DeviceType"
                        }
                    ]
                },
                "userName": {
                    "description": "登录用户名",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.LoginRequest": {
            "type": "object",
            "required": [
                "password",
                "userName"
            ],
            "properties": {
                "password": {
                    "description": "密码",
                    "type": "string"
                },
                "userName": {
                    "description": "用户名",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.PCDFileCreateRequest": {
            "type": "object",
            "required": [
                "area",
                "name",
                "path",
                "size",
                "userName"
            ],
            "properties": {
                "area": {
                    "description": "区域描述",
                    "type": "string"
                },
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "minioPath": {
                    "description": "MinIO存储路径",
                    "type": "string"
                },
                "name": {
                    "description": "地图名称",
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "path": {
                    "description": "文件存储路径",
                    "type": "string"
                },
                "size": {
                    "description": "文件大小",
                    "type": "integer",
                    "minimum": 0
                },
                "userName": {
                    "description": "上传人员",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.PCDFileUpdateRequest": {
            "type": "object",
            "properties": {
                "area": {
                    "description": "区域描述",
                    "type": "string"
                },
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "minioPath": {
                    "description": "MinIO存储路径",
                    "type": "string"
                },
                "name": {
                    "description": "地图名称",
                    "type": "string",
                    "maxLength": 100,
                    "minLength": 1
                },
                "path": {
                    "description": "文件存储路径",
                    "type": "string"
                },
                "size": {
                    "description": "文件大小",
                    "type": "integer",
                    "minimum": 0
                },
                "userName": {
                    "description": "上传人员",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.PCDFileUploadTokenRequest": {
            "type": "object",
            "required": [
                "fileName",
                "size"
            ],
            "properties": {
                "fileName": {
                    "description": "原始文件名",
                    "type": "string"
                },
                "size": {
                    "description": "文件大小(字节)",
                    "type": "integer",
                    "minimum": 0
                }
            }
        },
        "robot_scheduler_internal_model_dto.SemanticMapCreateRequest": {
            "type": "object",
            "required": [
                "pcdFileId",
                "semanticInfo",
                "userName"
            ],
            "properties": {
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "pcdFileId": {
                    "description": "对应的pcd地图文件id",
                    "type": "integer"
                },
                "semanticInfo": {
                    "description": "语义信息",
                    "type": "string"
                },
                "userName": {
                    "description": "编辑人员",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.SemanticMapUpdateRequest": {
            "type": "object",
            "properties": {
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "pcdFileId": {
                    "description": "对应的pcd地图文件id",
                    "type": "integer"
                },
                "semanticInfo": {
                    "description": "语义信息",
                    "type": "string"
                },
                "userName": {
                    "description": "编辑人员",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.TaskCreateRequest": {
            "type": "object",
            "required": [
                "semanticMapId",
                "taskInfo",
                "userName"
            ],
            "properties": {
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "semanticMapId": {
                    "description": "对应的语义地图id",
                    "type": "integer"
                },
                "taskInfo": {
                    "description": "任务信息",
                    "type": "string"
                },
                "userName": {
                    "description": "编辑人员",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.TaskUpdateRequest": {
            "type": "object",
            "properties": {
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "semanticMapId": {
                    "description": "对应的语义地图id",
                    "type": "integer"
                },
                "status": {
                    "description": "任务状态",
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.TaskStatus"
                        }
                    ]
                },
                "taskInfo": {
                    "description": "任务信息",
                    "type": "string"
                },
                "userName": {
                    "description": "编辑人员",
                    "type": "string"
                }
            }
        },
        "robot_scheduler_internal_model_dto.UserCreateRequest": {
            "type": "object",
            "required": [
                "password",
                "role",
                "userName"
            ],
            "properties": {
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "password": {
                    "description": "密码",
                    "type": "string",
                    "minLength": 6
                },
                "role": {
                    "description": "角色",
                    "enum": [
                        "administrator",
                        "manager",
                        "operator",
                        "user"
                    ],
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.RoleType"
                        }
                    ]
                },
                "userName": {
                    "description": "用户名",
                    "type": "string",
                    "maxLength": 50,
                    "minLength": 3
                }
            }
        },
        "robot_scheduler_internal_model_dto.UserUpdateRequest": {
            "type": "object",
            "properties": {
                "extraInfo": {
                    "description": "扩展信息",
                    "type": "string"
                },
                "isLocked": {
                    "description": "是否锁定",
                    "type": "integer",
                    "enum": [
                        0,
                        1
                    ]
                },
                "password": {
                    "description": "密码",
                    "type": "string"
                },
                "role": {
                    "description": "角色",
                    "allOf": [
                        {
                            "$ref": "#/definitions/robot_scheduler_internal_model_entity.RoleType"
                        }
                    ]
                }
            }
        },
        "robot_scheduler_internal_model_entity.CompanyType": {
            "type": "string",
            "enum": [
                "cyborg"
            ],
            "x-enum-comments": {
                "CompanyCyborg": "赛博格"
            },
            "x-enum-descriptions": [
                "赛博格"
            ],
            "x-enum-varnames": [
                "CompanyCyborg"
            ]
        },
        "robot_scheduler_internal_model_entity.DeviceStatus": {
            "type": "string",
            "enum": [
                "offline",
                "online",
                "busy",
                "error"
            ],
            "x-enum-comments": {
                "DeviceStatusBusy": "忙碌",
                "DeviceStatusError": "错误",
                "DeviceStatusOffline": "离线",
                "DeviceStatusOnline": "在线"
            },
            "x-enum-descriptions": [
                "离线",
                "在线",
                "忙碌",
                "错误"
            ],
            "x-enum-varnames": [
                "DeviceStatusOffline",
                "DeviceStatusOnline",
                "DeviceStatusBusy",
                "DeviceStatusError"
            ]
        },
        "robot_scheduler_internal_model_entity.DeviceType": {
            "type": "string",
            "enum": [
                "robot_wheel",
                "robot_biped"
            ],
            "x-enum-comments": {
                "DeviceTypeBipedRobot": "双足机器人",
                "DeviceTypeWheelRobot": "轮式机器人"
            },
            "x-enum-descriptions": [
                "轮式机器人",
                "双足机器人"
            ],
            "x-enum-varnames": [
                "DeviceTypeWheelRobot",
                "DeviceTypeBipedRobot"
            ]
        },
        "robot_scheduler_internal_model_entity.RoleType": {
            "type": "string",
            "enum": [
                "administrator",
                "manager",
                "operator",
                "user"
            ],
            "x-enum-comments": {
                "RoleAdministrator": "超级管理员",
                "RoleManager": "管理员",
                "RoleOperator": "操作员",
                "RoleUser": "普通用户"
            },
            "x-enum-descriptions": [
                "超级管理员",
                "管理员",
                "操作员",
                "普通用户"
            ],
            "x-enum-varnames": [
                "RoleAdministrator",
                "RoleManager",
                "RoleOperator",
                "RoleUser"
            ]
        },
        "robot_scheduler_internal_model_entity.TaskStatus": {
            "type": "string",
            "enum": [
                "pending",
                "running",
                "completed",
                "failed",
                "cancelled"
            ],
            "x-enum-comments": {
                "TaskStatusCancelled": "已取消",
                "TaskStatusCompleted": "已完成",
                "TaskStatusFailed": "失败",
                "TaskStatusPending": "待执行",
                "TaskStatusRunning": "执行中"
            },
            "x-enum-descriptions": [
                "待执行",
                "执行中",
                "已完成",
                "失败",
                "已取消"
            ],
            "x-enum-varnames": [
                "TaskStatusPending",
                "TaskStatusRunning",
                "TaskStatusCompleted",
                "TaskStatusFailed",
                "TaskStatusCancelled"
            ]
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "机器人调度系统 API",
        Description:      "机器人调度系统后台管理接口",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>

                <pre class="file" id="file2" style="display: none">package handler

import (
        "net/http"

        "robot_scheduler/internal/logger"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// Response 统一响应结构
type Response struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data"`
}

// Success 成功响应
func Success(c *gin.Context, data interface{}) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, Response{
                Code:    0,
                Message: "success",
                Data:    data,
        })
}</span>

// Error 错误响应
func Error(c *gin.Context, code int, message string) <span class="cov0" title="0">{
        logger.Error("api error", zap.Int("code", code), zap.String("message", message))
        c.JSON(http.StatusOK, Response{
                Code:    code,
                Message: message,
                Data:    nil,
        })
}</span>

// BadRequest 请求参数错误
func BadRequest(c *gin.Context, message string) <span class="cov0" title="0">{
        Error(c, 400, message)
}</span>

// Unauthorized 未授权
func Unauthorized(c *gin.Context, message string) <span class="cov0" title="0">{
        Error(c, 401, message)
}</span>

// Forbidden 禁止访问
func Forbidden(c *gin.Context, message string) <span class="cov0" title="0">{
        Error(c, 403, message)
}</span>

// NotFound 资源不存在
func NotFound(c *gin.Context, message string) <span class="cov0" title="0">{
        Error(c, 404, message)
}</span>

// InternalServerError 服务器内部错误
func InternalServerError(c *gin.Context, message string) <span class="cov0" title="0">{
        Error(c, 500, message)
}</span>

// ForbiddenPermission 权限不足
func ForbiddenPermission(c *gin.Context, message string) <span class="cov0" title="0">{
        if message == "" </span><span class="cov0" title="0">{
                message = "权限不足：您没有执行此操作的权限"
        }</span>
        <span class="cov0" title="0">Error(c, 403, message)</span>
}
</pre>

                <pre class="file" id="file3" style="display: none">package handler

import (
        "strconv"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// DeviceHandler 设备处理器
type DeviceHandler struct {
        deviceService *service.DeviceService
}

func NewDeviceHandler(deviceService *service.DeviceService) *DeviceHandler <span class="cov0" title="0">{
        return &amp;DeviceHandler{
                deviceService: deviceService,
        }
}</span>

// CreateDevice 创建设备
// @Summary 创建设备
// @Description 创建新设备
// @Tags 设备管理
// @Accept json
// @Produce json
// @Param request body dto.DeviceCreateRequest true "设备信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /devices [post]
// @Security BearerAuth
func (h *DeviceHandler) CreateDevice(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling create device request")

        var req dto.DeviceCreateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">device, err := h.deviceService.CreateDevice(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create device", zap.Error(err))
                InternalServerError(c, "创建设备失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, device)</span>
}

// GetDevice 获取设备
// @Summary 获取设备
// @Description 根据ID获取设备信息
// @Tags 设备管理
// @Accept json
// @Produce json
// @Param id path int true "设备ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "设备不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /devices/{id} [get]
// @Security BearerAuth
func (h *DeviceHandler) GetDevice(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid device id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的设备ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling get device request", zap.Uint("id", uint(id)))

        device, err := h.deviceService.GetDeviceByID(c.Request.Context(), uint(id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get device", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "获取设备失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">if device == nil </span><span class="cov0" title="0">{
                logger.Warn("device not found", zap.Uint("id", uint(id)))
                NotFound(c, "设备不存在")
                return
        }</span>

        <span class="cov0" title="0">Success(c, device)</span>
}

// UpdateDevice 更新设备
// @Summary 更新设备
// @Description 更新设备信息
// @Tags 设备管理
// @Accept json
// @Produce json
// @Param id path int true "设备ID"
// @Param request body dto.DeviceUpdateRequest true "更新信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "设备不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /devices/{id} [put]
// @Security BearerAuth
func (h *DeviceHandler) UpdateDevice(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid device id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的设备ID")
                return
        }</span>

        <span class="cov0" title="0">var req dto.DeviceUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling update device request", zap.Uint("id", uint(id)))

        if err := h.deviceService.UpdateDevice(c.Request.Context(), uint(id), &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update device", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "更新设备失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "更新成功"})</span>
}

// DeleteDevice 删除设备
// @Summary 删除设备
// @Description 删除设备（软删除）
// @Tags 设备管理
// @Accept json
// @Produce json
// @Param id path int true "设备ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /devices/{id} [delete]
// @Security BearerAuth
func (h *DeviceHandler) DeleteDevice(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid device id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的设备ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling delete device request", zap.Uint("id", uint(id)))

        if err := h.deviceService.DeleteDevice(c.Request.Context(), uint(id)); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete device", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "删除设备失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "删除成功"})</span>
}

// ListDevices 查询设备列表
// @Summary 查询设备列表
// @Description 查询所有设备
// @Tags 设备管理
// @Accept json
// @Produce json
// @Success 200 {object} Response "成功"
// @Failure 500 {object} Response "服务器错误"
// @Router /devices [get]
// @Security BearerAuth
func (h *DeviceHandler) ListDevices(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling list devices request")

        var pageReq dto.PageRequest
        if err := c.ShouldBindQuery(&amp;pageReq); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pagination parameters", zap.Error(err))
                BadRequest(c, "无效的分页参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">devices, err := h.deviceService.ListDevices(c.Request.Context(), pageReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to list devices", zap.Error(err))
                InternalServerError(c, "查询设备列表失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, devices)</span>
}
</pre>

                <pre class="file" id="file4" style="display: none">package handler

import (
        "strconv"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// UserOperationHandler 操作记录处理器
type UserOperationHandler struct {
        operationService *service.UserOperationService
}

func NewUserOperationHandler(operationService *service.UserOperationService) *UserOperationHandler <span class="cov0" title="0">{
        return &amp;UserOperationHandler{
                operationService: operationService,
        }
}</span>

// GetOperation 获取操作记录
// @Summary 获取操作记录
// @Description 根据ID获取操作记录信息
// @Tags 操作记录
// @Accept json
// @Produce json
// @Param id path int true "操作记录ID"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "操作记录不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /operations/{id} [get]
// @Security BearerAuth
func (h *UserOperationHandler) GetOperation(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid operation id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的操作记录ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling get operation request", zap.Uint("id", uint(id)))

        operation, err := h.operationService.GetOperationByID(c.Request.Context(), uint(id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get operation", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "获取操作记录失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">if operation == nil </span><span class="cov0" title="0">{
                logger.Warn("operation not found", zap.Uint("id", uint(id)))
                NotFound(c, "操作记录不存在")
                return
        }</span>

        <span class="cov0" title="0">Success(c, operation)</span>
}

// ListOperations 查询操作记录列表
// @Summary 查询操作记录列表
// @Description 查询所有操作记录
// @Tags 操作记录
// @Accept json
// @Produce json
// @Success 200 {object} Response "成功"
// @Failure 500 {object} Response "服务器错误"
// @Router /operations [get]
// @Security BearerAuth
func (h *UserOperationHandler) ListOperations(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling list operations request")

        var pageReq dto.PageRequest
        if err := c.ShouldBindQuery(&amp;pageReq); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pagination parameters", zap.Error(err))
                BadRequest(c, "无效的分页参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">operations, err := h.operationService.ListOperations(c.Request.Context(), pageReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to list operations", zap.Error(err))
                InternalServerError(c, "查询操作记录列表失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, operations)</span>
}
</pre>

                <pre class="file" id="file5" style="display: none">package handler

import (
        "strconv"

        "robot_scheduler/internal/api/middleware"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// PCDFileHandler 点云地图处理器
type PCDFileHandler struct {
        pcdService *service.PCDFileService
}

func NewPCDFileHandler(pcdService *service.PCDFileService) *PCDFileHandler <span class="cov0" title="0">{
        return &amp;PCDFileHandler{
                pcdService: pcdService,
        }
}</span>

// GetPCDUploadToken 获取点云地图上传凭证
// @Summary 获取点云地图上传凭证
// @Description 返回 MinIO 预签名上传 URL
// @Tags 点云地图
// @Accept json
// @Produce json
// @Param request body dto.PCDFileUploadTokenRequest true "上传文件信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/pcd-files/upload-token [post]
// @Security BearerAuth
func (h *PCDFileHandler) GetPCDUploadToken(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling get pcd upload token request")

        var req dto.PCDFileUploadTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid upload token request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        // 从 JWT 上下文中获取用户名
        <span class="cov0" title="0">userNameValue, _ := c.Get(string(middleware.UserNameKey))
        userName, _ := userNameValue.(string)

        resp, err := h.pcdService.GenerateUploadToken(c.Request.Context(), userName, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to generate pcd upload token", zap.Error(err))
                InternalServerError(c, "生成上传凭证失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, resp)</span>
}

// CreatePCDFile 创建点云地图
// @Summary 创建点云地图
// @Description 创建新点云地图
// @Tags 点云地图
// @Accept json
// @Produce json
// @Param request body dto.PCDFileCreateRequest true "点云地图信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/pcd-files [post]
// @Security BearerAuth
func (h *PCDFileHandler) CreatePCDFile(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling create pcd file request")

        var req dto.PCDFileCreateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">file, err := h.pcdService.CreatePCDFile(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create pcd file", zap.Error(err))
                InternalServerError(c, "创建点云地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, file)</span>
}

// GetPCDFile 获取点云地图
// @Summary 获取点云地图
// @Description 根据ID获取点云地图信息
// @Tags 点云地图
// @Accept json
// @Produce json
// @Param id path int true "点云地图ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "点云地图不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/pcd-files/{id} [get]
// @Security BearerAuth
func (h *PCDFileHandler) GetPCDFile(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pcd file id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的点云地图ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling get pcd file request", zap.Uint("id", uint(id)))

        file, err := h.pcdService.GetPCDFileByID(c.Request.Context(), uint(id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get pcd file", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "获取点云地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">if file == nil </span><span class="cov0" title="0">{
                logger.Warn("pcd file not found", zap.Uint("id", uint(id)))
                NotFound(c, "点云地图不存在")
                return
        }</span>

        <span class="cov0" title="0">Success(c, file)</span>
}

// UpdatePCDFile 更新点云地图
// @Summary 更新点云地图
// @Description 更新点云地图信息
// @Tags 点云地图
// @Accept json
// @Produce json
// @Param id path int true "点云地图ID"
// @Param request body dto.PCDFileUpdateRequest true "更新信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "点云地图不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/pcd-files/{id} [put]
// @Security BearerAuth
func (h *PCDFileHandler) UpdatePCDFile(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pcd file id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的点云地图ID")
                return
        }</span>

        <span class="cov0" title="0">var req dto.PCDFileUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling update pcd file request", zap.Uint("id", uint(id)))

        if err := h.pcdService.UpdatePCDFile(c.Request.Context(), uint(id), &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update pcd file", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "更新点云地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "更新成功"})</span>
}

// DeletePCDFile 删除点云地图
// @Summary 删除点云地图
// @Description 删除点云地图（软删除）
// @Tags 点云地图
// @Accept json
// @Produce json
// @Param id path int true "点云地图ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/pcd-files/{id} [delete]
// @Security BearerAuth
func (h *PCDFileHandler) DeletePCDFile(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pcd file id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的点云地图ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling delete pcd file request", zap.Uint("id", uint(id)))

        if err := h.pcdService.DeletePCDFile(c.Request.Context(), uint(id)); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete pcd file", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "删除点云地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "删除成功"})</span>
}

// ListPCDFiles 查询点云地图列表
// @Summary 查询点云地图列表
// @Description 查询所有点云地图
// @Tags 点云地图
// @Accept json
// @Produce json
// @Success 200 {object} Response "成功"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/pcd-files [get]
// @Security BearerAuth
func (h *PCDFileHandler) ListPCDFiles(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling list pcd files request")

        var pageReq dto.PageRequest
        if err := c.ShouldBindQuery(&amp;pageReq); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pagination parameters", zap.Error(err))
                BadRequest(c, "无效的分页参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">files, err := h.pcdService.ListPCDFiles(c.Request.Context(), pageReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to list pcd files", zap.Error(err))
                InternalServerError(c, "查询点云地图列表失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, files)</span>
}
</pre>

                <pre class="file" id="file6" style="display: none">package handler

import (
        "strconv"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// SemanticMapHandler 语义地图处理器
type SemanticMapHandler struct {
        semanticService *service.SemanticMapService
}

func NewSemanticMapHandler(semanticService *service.SemanticMapService) *SemanticMapHandler <span class="cov0" title="0">{
        return &amp;SemanticMapHandler{
                semanticService: semanticService,
        }
}</span>

// CreateSemanticMap 创建语义地图
// @Summary 创建语义地图
// @Description 创建新语义地图
// @Tags 语义地图
// @Accept json
// @Produce json
// @Param request body dto.SemanticMapCreateRequest true "语义地图信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/semantic-maps [post]
// @Security BearerAuth
func (h *SemanticMapHandler) CreateSemanticMap(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling create semantic map request")

        var req dto.SemanticMapCreateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">semanticMap, err := h.semanticService.CreateSemanticMap(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create semantic map", zap.Error(err))
                InternalServerError(c, "创建语义地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, semanticMap)</span>
}

// GetSemanticMap 获取语义地图
// @Summary 获取语义地图
// @Description 根据ID获取语义地图信息
// @Tags 语义地图
// @Accept json
// @Produce json
// @Param id path int true "语义地图ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "语义地图不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/semantic-maps/{id} [get]
// @Security BearerAuth
func (h *SemanticMapHandler) GetSemanticMap(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid semantic map id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的语义地图ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling get semantic map request", zap.Uint("id", uint(id)))

        semanticMap, err := h.semanticService.GetSemanticMapByID(c.Request.Context(), uint(id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get semantic map", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "获取语义地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">if semanticMap == nil </span><span class="cov0" title="0">{
                logger.Warn("semantic map not found", zap.Uint("id", uint(id)))
                NotFound(c, "语义地图不存在")
                return
        }</span>

        <span class="cov0" title="0">Success(c, semanticMap)</span>
}

// UpdateSemanticMap 更新语义地图
// @Summary 更新语义地图
// @Description 更新语义地图信息
// @Tags 语义地图
// @Accept json
// @Produce json
// @Param id path int true "语义地图ID"
// @Param request body dto.SemanticMapUpdateRequest true "更新信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "语义地图不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/semantic-maps/{id} [put]
// @Security BearerAuth
func (h *SemanticMapHandler) UpdateSemanticMap(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid semantic map id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的语义地图ID")
                return
        }</span>

        <span class="cov0" title="0">var req dto.SemanticMapUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling update semantic map request", zap.Uint("id", uint(id)))

        if err := h.semanticService.UpdateSemanticMap(c.Request.Context(), uint(id), &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update semantic map", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "更新语义地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "更新成功"})</span>
}

// DeleteSemanticMap 删除语义地图
// @Summary 删除语义地图
// @Description 删除语义地图（软删除）
// @Tags 语义地图
// @Accept json
// @Produce json
// @Param id path int true "语义地图ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/semantic-maps/{id} [delete]
// @Security BearerAuth
func (h *SemanticMapHandler) DeleteSemanticMap(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid semantic map id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的语义地图ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling delete semantic map request", zap.Uint("id", uint(id)))

        if err := h.semanticService.DeleteSemanticMap(c.Request.Context(), uint(id)); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete semantic map", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "删除语义地图失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "删除成功"})</span>
}

// ListSemanticMaps 查询语义地图列表
// @Summary 查询语义地图列表
// @Description 查询所有语义地图
// @Tags 语义地图
// @Accept json
// @Produce json
// @Success 200 {object} Response "成功"
// @Failure 500 {object} Response "服务器错误"
// @Router /maps/semantic-maps [get]
// @Security BearerAuth
func (h *SemanticMapHandler) ListSemanticMaps(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling list semantic maps request")

        var pageReq dto.PageRequest
        if err := c.ShouldBindQuery(&amp;pageReq); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pagination parameters", zap.Error(err))
                BadRequest(c, "无效的分页参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">semanticMaps, err := h.semanticService.ListSemanticMaps(c.Request.Context(), pageReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to list semantic maps", zap.Error(err))
                InternalServerError(c, "查询语义地图列表失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, semanticMaps)</span>
}
</pre>

                <pre class="file" id="file7" style="display: none">package handler

import (
        "strconv"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// TaskHandler 任务处理器
type TaskHandler struct {
        taskService *service.TaskService
}

func NewTaskHandler(taskService *service.TaskService) *TaskHandler <span class="cov0" title="0">{
        return &amp;TaskHandler{
                taskService: taskService,
        }
}</span>

// CreateTask 创建任务
// @Summary 创建任务
// @Description 创建新任务
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param request body dto.TaskCreateRequest true "任务信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /tasks [post]
// @Security BearerAuth
func (h *TaskHandler) CreateTask(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling create task request")

        var req dto.TaskCreateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">task, err := h.taskService.CreateTask(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create task", zap.Error(err))
                InternalServerError(c, "创建任务失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, task)</span>
}

// GetTask 获取任务
// @Summary 获取任务
// @Description 根据ID获取任务信息
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param id path int true "任务ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "任务不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /tasks/{id} [get]
// @Security BearerAuth
func (h *TaskHandler) GetTask(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid task id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的任务ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling get task request", zap.Uint("id", uint(id)))

        task, err := h.taskService.GetTaskByID(c.Request.Context(), uint(id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get task", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "获取任务失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                logger.Warn("task not found", zap.Uint("id", uint(id)))
                NotFound(c, "任务不存在")
                return
        }</span>

        <span class="cov0" title="0">Success(c, task)</span>
}

// UpdateTask 更新任务
// @Summary 更新任务
// @Description 更新任务信息
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param id path int true "任务ID"
// @Param request body dto.TaskUpdateRequest true "更新信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "任务不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /tasks/{id} [put]
// @Security BearerAuth
func (h *TaskHandler) UpdateTask(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid task id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的任务ID")
                return
        }</span>

        <span class="cov0" title="0">var req dto.TaskUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling update task request", zap.Uint("id", uint(id)))

        if err := h.taskService.UpdateTask(c.Request.Context(), uint(id), &amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update task", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "更新任务失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "更新成功"})</span>
}

// DeleteTask 删除任务
// @Summary 删除任务
// @Description 删除任务（软删除）
// @Tags 任务管理
// @Accept json
// @Produce json
// @Param id path int true "任务ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /tasks/{id} [delete]
// @Security BearerAuth
func (h *TaskHandler) DeleteTask(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid task id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的任务ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling delete task request", zap.Uint("id", uint(id)))

        if err := h.taskService.DeleteTask(c.Request.Context(), uint(id)); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete task", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "删除任务失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "删除成功"})</span>
}

// ListTasks 查询任务列表
// @Summary 查询任务列表
// @Description 查询所有任务
// @Tags 任务管理
// @Accept json
// @Produce json
// @Success 200 {object} Response "成功"
// @Failure 500 {object} Response "服务器错误"
// @Router /tasks [get]
// @Security BearerAuth
func (h *TaskHandler) ListTasks(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling list tasks request")

        var pageReq dto.PageRequest
        if err := c.ShouldBindQuery(&amp;pageReq); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pagination parameters", zap.Error(err))
                BadRequest(c, "无效的分页参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">tasks, err := h.taskService.ListTasks(c.Request.Context(), pageReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to list tasks", zap.Error(err))
                InternalServerError(c, "查询任务列表失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, tasks)</span>
}
</pre>

                <pre class="file" id="file8" style="display: none">package handler

import (
        "strconv"

        "robot_scheduler/internal/config"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/service"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// UserHandler 用户处理器
type UserHandler struct {
        userService *service.UserService
        config      *config.Config
}

func NewUserHandler(userService *service.UserService, cfg *config.Config) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
                config:      cfg,
        }
}</span>

// CreateUser 创建用户
// @Summary 创建用户
// @Description 创建新用户
// @Tags 用户管理
// @Accept json
// @Produce json
// @Param request body dto.UserCreateRequest true "用户信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /users [post]
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling create user request")

        var req dto.UserCreateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">authConfig := h.config.Auth
        if authConfig == nil || authConfig.DESKey == "" </span><span class="cov0" title="0">{
                logger.Error("auth config or DES key not found")
                InternalServerError(c, "认证配置缺失或DES密钥未配置")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.CreateUser(c.Request.Context(), &amp;req, authConfig.DESKey)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create user", zap.Error(err))
                InternalServerError(c, "创建用户失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, user)</span>
}

// GetUser 获取用户
// @Summary 获取用户
// @Description 根据ID获取用户信息
// @Tags 用户管理
// @Accept json
// @Produce json
// @Param id path int true "用户ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "用户不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /users/{id} [get]
func (h *UserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid user id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的用户ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling get user request", zap.Uint("id", uint(id)))

        user, err := h.userService.GetUserByID(c.Request.Context(), uint(id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "获取用户失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                logger.Warn("user not found", zap.Uint("id", uint(id)))
                NotFound(c, "用户不存在")
                return
        }</span>

        <span class="cov0" title="0">Success(c, user)</span>
}

// UpdateUser 更新用户
// @Summary 更新用户
// @Description 更新用户信息
// @Tags 用户管理
// @Accept json
// @Produce json
// @Param id path int true "用户ID"
// @Param request body dto.UserUpdateRequest true "更新信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 404 {object} Response "用户不存在"
// @Failure 500 {object} Response "服务器错误"
// @Router /users/{id} [put]
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid user id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的用户ID")
                return
        }</span>

        <span class="cov0" title="0">var req dto.UserUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">authConfig := h.config.Auth
        if authConfig == nil || authConfig.DESKey == "" </span><span class="cov0" title="0">{
                logger.Error("auth config or DES key not found")
                InternalServerError(c, "认证配置缺失或DES密钥未配置")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling update user request", zap.Uint("id", uint(id)))

        if err := h.userService.UpdateUser(c.Request.Context(), uint(id), &amp;req, authConfig.DESKey); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update user", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "更新用户失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "更新成功"})</span>
}

// DeleteUser 删除用户
// @Summary 删除用户
// @Description 删除用户（软删除）
// @Tags 用户管理
// @Accept json
// @Produce json
// @Param id path int true "用户ID"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 500 {object} Response "服务器错误"
// @Router /users/{id} [delete]
func (h *UserHandler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid user id", zap.String("id", idStr), zap.Error(err))
                BadRequest(c, "无效的用户ID")
                return
        }</span>

        <span class="cov0" title="0">logger.Info("handling delete user request", zap.Uint("id", uint(id)))

        if err := h.userService.DeleteUser(c.Request.Context(), uint(id)); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete user", zap.Error(err), zap.Uint("id", uint(id)))
                InternalServerError(c, "删除用户失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "删除成功"})</span>
}

// ListUsers 查询用户列表
// @Summary 查询用户列表
// @Description 查询所有用户
// @Tags 用户管理
// @Accept json
// @Produce json
// @Success 200 {object} Response "成功"
// @Failure 500 {object} Response "服务器错误"
// @Router /users [get]
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling list users request")

        var pageReq dto.PageRequest
        if err := c.ShouldBindQuery(&amp;pageReq); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid pagination parameters", zap.Error(err))
                BadRequest(c, "无效的分页参数: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">users, err := h.userService.ListUsers(c.Request.Context(), pageReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to list users", zap.Error(err))
                InternalServerError(c, "查询用户列表失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, users)</span>
}

// Login 用户登录
// @Summary 用户登录
// @Description 用户登录，返回JWT token
// @Tags 认证
// @Accept json
// @Produce json
// @Param request body dto.LoginRequest true "登录信息"
// @Success 200 {object} Response "成功"
// @Failure 400 {object} Response "参数错误"
// @Failure 401 {object} Response "用户名或密码错误"
// @Router /auth/login [post]
func (h *UserHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling login request")

        var req dto.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error("invalid request parameters", zap.Error(err))
                BadRequest(c, "无效的请求参数: "+err.Error())
                return
        }</span>

        // 获取认证配置
        <span class="cov0" title="0">authConfig := h.config.Auth
        if authConfig == nil </span><span class="cov0" title="0">{
                logger.Error("auth config not found")
                InternalServerError(c, "认证配置未找到")
                return
        }</span>

        // 调用服务层登录
        <span class="cov0" title="0">response, err := h.userService.Login(
                c.Request.Context(),
                req.UserName,
                req.Password,
                authConfig.DESKey,
                authConfig.JWTSecret,
                authConfig.JWTExpireHours,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("login failed", zap.Error(err), zap.String("username", req.UserName))
                Unauthorized(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, response)</span>
}

// Logout 用户退出
// @Summary 用户退出
// @Description 用户退出登录
// @Tags 认证
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} Response "成功"
// @Router /auth/logout [post]
func (h *UserHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        logger.Info("handling logout request")

        if err := h.userService.Logout(c.Request.Context()); err != nil </span><span class="cov0" title="0">{
                logger.Error("logout failed", zap.Error(err))
                InternalServerError(c, "退出失败: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">Success(c, gin.H{"message": "退出成功"})</span>
}
</pre>

                <pre class="file" id="file9" style="display: none">package middleware

import (
        "strings"
        "time"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"
        "robot_scheduler/internal/utils"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// ContextKey 上下文键类型
type ContextKey string

const (
        // UserIDKey 用户ID上下文键
        UserIDKey ContextKey = "user_id"
        // UserNameKey 用户名上下文键
        UserNameKey ContextKey = "user_name"
        // UserRoleKey 用户角色上下文键
        UserRoleKey ContextKey = "user_role"
)

// Recovery 恢复中间件
func Recovery() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                if err, ok := recovered.(string); ok </span><span class="cov0" title="0">{
                        logger.Error("panic recovered",
                                zap.String("path", c.Request.URL.Path),
                                zap.String("error", err),
                        )
                }</span>
                <span class="cov0" title="0">c.AbortWithStatusJSON(500, gin.H{
                        "code":    500,
                        "message": "Internal Server Error",
                })</span>
        })
}

// Logger 日志中间件
func Logger() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                query := c.Request.URL.RawQuery

                c.Next()

                cost := time.Since(start)

                logger.Info(path,
                        zap.Int("status", c.Writer.Status()),
                        zap.String("method", c.Request.Method),
                        zap.String("path", path),
                        zap.String("query", query),
                        zap.String("ip", c.ClientIP()),
                        zap.String("user-agent", c.Request.UserAgent()),
                        zap.String("errors", c.Errors.ByType(gin.ErrorTypePrivate).String()),
                        zap.Duration("cost", cost),
                )
        }</span>
}

// CORS 跨域中间件
func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// JWTAuth JWT认证中间件
func JWTAuth(jwtSecret string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 从Header中获取token
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        logger.Warn("missing authorization header", zap.String("path", c.Request.URL.Path))
                        c.AbortWithStatusJSON(401, gin.H{
                                "code":    401,
                                "message": "未授权，请先登录",
                        })
                        return
                }</span>

                // 提取token（格式：Bearer &lt;token&gt;）
                <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        logger.Warn("invalid authorization header format", zap.String("path", c.Request.URL.Path))
                        c.AbortWithStatusJSON(401, gin.H{
                                "code":    401,
                                "message": "无效的授权头格式",
                        })
                        return
                }</span>

                <span class="cov0" title="0">tokenString := parts[1]

                // 验证token
                claims, err := utils.ValidateToken(tokenString, jwtSecret)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("invalid token", zap.Error(err), zap.String("path", c.Request.URL.Path))
                        c.AbortWithStatusJSON(401, gin.H{
                                "code":    401,
                                "message": "无效的token或token已过期",
                        })
                        return
                }</span>

                // 将用户信息存入context
                <span class="cov0" title="0">c.Set(string(UserIDKey), claims.UserID)
                c.Set(string(UserNameKey), claims.UserName)
                c.Set(string(UserRoleKey), claims.Role)

                c.Next()</span>
        }
}

// RequirePermission 权限检查中间件
// 要求用户拥有至少一个指定的权限
func RequirePermission(permissions ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 从context中获取用户角色
                roleValue, exists := c.Get(string(UserRoleKey))
                if !exists </span><span class="cov0" title="0">{
                        logger.Warn("user role not found in context", zap.String("path", c.Request.URL.Path))
                        c.AbortWithStatusJSON(403, gin.H{
                                "code":    403,
                                "message": "权限不足：无法获取用户角色",
                        })
                        return
                }</span>

                <span class="cov0" title="0">role, ok := roleValue.(entity.RoleType)
                if !ok </span><span class="cov0" title="0">{
                        logger.Warn("invalid role type in context", zap.String("path", c.Request.URL.Path))
                        c.AbortWithStatusJSON(403, gin.H{
                                "code":    403,
                                "message": "权限不足：无效的用户角色",
                        })
                        return
                }</span>

                // 检查权限
                <span class="cov0" title="0">if !utils.HasAnyPermission(role, permissions...) </span><span class="cov0" title="0">{
                        logger.Warn("permission denied",
                                zap.String("path", c.Request.URL.Path),
                                zap.String("role", string(role)),
                                zap.Strings("required_permissions", permissions),
                        )
                        c.AbortWithStatusJSON(403, gin.H{
                                "code":    403,
                                "message": "权限不足：您没有执行此操作的权限",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>

                <pre class="file" id="file10" style="display: none">package router

import (
        "robot_scheduler/internal/api/handler"
        "robot_scheduler/internal/api/middleware"
        "robot_scheduler/internal/config"
        impl "robot_scheduler/internal/dao"
        "robot_scheduler/internal/database"
        "robot_scheduler/internal/service"
        "robot_scheduler/internal/utils"
        "time"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// SetupRouter 设置路由
func SetupRouter(router *gin.Engine, cfg *config.Config) <span class="cov0" title="0">{
        // 初始化DAO
        db := database.DB

        // 用户相关
        userDAO := impl.NewUserDAO(db)
        userService := service.NewUserService(userDAO)
        userHandler := handler.NewUserHandler(userService, cfg)

        // 点云地图相关
        pcdDAO := impl.NewPCDFileDAO(db)
        pcdService := service.NewPCDFileService(pcdDAO)
        pcdHandler := handler.NewPCDFileHandler(pcdService)

        // 语义地图相关
        semanticDAO := impl.NewSemanticMapDAO(db)
        semanticService := service.NewSemanticMapService(semanticDAO)
        semanticHandler := handler.NewSemanticMapHandler(semanticService)

        // 任务相关
        taskDAO := impl.NewTaskDAO(db)
        taskService := service.NewTaskService(taskDAO)
        taskHandler := handler.NewTaskHandler(taskService)

        // 设备相关
        deviceDAO := impl.NewDeviceDAO(db)
        deviceService := service.NewDeviceService(deviceDAO)
        deviceHandler := handler.NewDeviceHandler(deviceService)

        // 操作记录相关
        operationDAO := impl.NewUserOperationDAO(db)
        operationService := service.NewUserOperationService(operationDAO)
        operationHandler := handler.NewUserOperationHandler(operationService)

        // Swagger 文档
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // 健康检查
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "status":    "ok",
                        "timestamp": time.Now().Format(time.RFC3339),
                        "service":   "robot-scheduler",
                        "version":   "1.0.0",
                })
        }</span>)

        // API路由组
        <span class="cov0" title="0">api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // 认证路由
                authConfig := cfg.Auth
                if authConfig == nil || authConfig.JWTSecret == "" </span><span class="cov0" title="0">{
                        panic("JWT secret not configured")</span>
                }

                // 登录路由（无需JWT认证）
                <span class="cov0" title="0">auth := api.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/login", userHandler.Login)
                }</span>

                // 需要JWT认证的路由组
                <span class="cov0" title="0">authenticated := api.Group("")
                authenticated.Use(middleware.JWTAuth(authConfig.JWTSecret))
                </span><span class="cov0" title="0">{
                        // 退出路由（需要认证）
                        authAuthenticated := authenticated.Group("/auth")
                        </span><span class="cov0" title="0">{
                                authAuthenticated.POST("/logout", userHandler.Logout)
                        }</span>

                        // 用户管理
                        <span class="cov0" title="0">users := authenticated.Group("/users")
                        </span><span class="cov0" title="0">{
                                // 创建/编辑/删除需要用户管理权限
                                users.POST("", middleware.RequirePermission(utils.PermissionUserManage), userHandler.CreateUser)
                                users.PUT("/:id", middleware.RequirePermission(utils.PermissionUserManage), userHandler.UpdateUser)
                                users.DELETE("/:id", middleware.RequirePermission(utils.PermissionUserManage), userHandler.DeleteUser)
                                // 查看需要用户查看权限
                                users.GET("/:id", middleware.RequirePermission(utils.PermissionUserView), userHandler.GetUser)
                                users.GET("", middleware.RequirePermission(utils.PermissionUserView), userHandler.ListUsers)
                        }</span>

                        // 地图管理模块
                        <span class="cov0" title="0">maps := authenticated.Group("/maps")
                        </span><span class="cov0" title="0">{
                                // 点云地图管理
                                pcds := maps.Group("/pcd-files")
                                </span><span class="cov0" title="0">{
                                        // 上传凭证与创建/编辑/删除需要地图管理权限
                                        pcds.POST("/upload-token", middleware.RequirePermission(utils.PermissionMapManage), pcdHandler.GetPCDUploadToken)
                                        pcds.POST("", middleware.RequirePermission(utils.PermissionMapManage), pcdHandler.CreatePCDFile)
                                        pcds.PUT("/:id", middleware.RequirePermission(utils.PermissionMapManage), pcdHandler.UpdatePCDFile)
                                        pcds.DELETE("/:id", middleware.RequirePermission(utils.PermissionMapManage), pcdHandler.DeletePCDFile)
                                        // 查看需要地图查看权限
                                        pcds.GET("/:id", middleware.RequirePermission(utils.PermissionMapView), pcdHandler.GetPCDFile)
                                        pcds.GET("", middleware.RequirePermission(utils.PermissionMapView), pcdHandler.ListPCDFiles)
                                }</span>

                                // 语义地图管理
                                <span class="cov0" title="0">semantics := maps.Group("/semantic-maps")
                                </span><span class="cov0" title="0">{
                                        // 创建/编辑/删除需要地图管理权限
                                        semantics.POST("", middleware.RequirePermission(utils.PermissionMapManage), semanticHandler.CreateSemanticMap)
                                        semantics.PUT("/:id", middleware.RequirePermission(utils.PermissionMapManage), semanticHandler.UpdateSemanticMap)
                                        semantics.DELETE("/:id", middleware.RequirePermission(utils.PermissionMapManage), semanticHandler.DeleteSemanticMap)
                                        // 查看需要地图查看权限
                                        semantics.GET("/:id", middleware.RequirePermission(utils.PermissionMapView), semanticHandler.GetSemanticMap)
                                        semantics.GET("", middleware.RequirePermission(utils.PermissionMapView), semanticHandler.ListSemanticMaps)
                                }</span>
                        }

                        // 任务管理
                        <span class="cov0" title="0">tasks := authenticated.Group("/tasks")
                        </span><span class="cov0" title="0">{
                                // 创建/编辑/删除需要任务管理权限
                                tasks.POST("", middleware.RequirePermission(utils.PermissionTaskManage), taskHandler.CreateTask)
                                tasks.PUT("/:id", middleware.RequirePermission(utils.PermissionTaskManage), taskHandler.UpdateTask)
                                tasks.DELETE("/:id", middleware.RequirePermission(utils.PermissionTaskManage), taskHandler.DeleteTask)
                                // 查看需要任务查看权限
                                tasks.GET("/:id", middleware.RequirePermission(utils.PermissionTaskView), taskHandler.GetTask)
                                tasks.GET("", middleware.RequirePermission(utils.PermissionTaskView), taskHandler.ListTasks)
                        }</span>

                        // 设备管理
                        <span class="cov0" title="0">devices := authenticated.Group("/devices")
                        </span><span class="cov0" title="0">{
                                // 创建/编辑/删除需要设备管理权限
                                devices.POST("", middleware.RequirePermission(utils.PermissionDeviceManage), deviceHandler.CreateDevice)
                                devices.PUT("/:id", middleware.RequirePermission(utils.PermissionDeviceManage), deviceHandler.UpdateDevice)
                                devices.DELETE("/:id", middleware.RequirePermission(utils.PermissionDeviceManage), deviceHandler.DeleteDevice)
                                // 查看需要设备查看权限（普通用户也可以）
                                devices.GET("/:id", middleware.RequirePermission(utils.PermissionDeviceView), deviceHandler.GetDevice)
                                devices.GET("", middleware.RequirePermission(utils.PermissionDeviceView), deviceHandler.ListDevices)
                        }</span>

                        // 操作记录查询（操作员及以上）
                        <span class="cov0" title="0">operations := authenticated.Group("/operations")
                        operations.Use(middleware.RequirePermission(utils.PermissionOperationView))
                        </span><span class="cov0" title="0">{
                                operations.GET("/:id", operationHandler.GetOperation)
                                operations.GET("", operationHandler.ListOperations)
                        }</span>
                }
        }
}
</pre>

                <pre class="file" id="file11" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "robot_scheduler/internal/api/middleware"
        "robot_scheduler/internal/api/router"
        "robot_scheduler/internal/config"
        "robot_scheduler/internal/logger"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

type Server struct {
        config *config.Config
        router *gin.Engine
        server *http.Server
}

func NewServer(cfg *config.Config) *Server <span class="cov0" title="0">{
        // 设置Gin模式
        if cfg.App.Mode == "release" </span><span class="cov0" title="0">{
                gin.SetMode(gin.ReleaseMode)
        }</span>

        // 创建Gin引擎
        <span class="cov0" title="0">engine := gin.New()

        // 注册中间件
        engine.Use(middleware.Recovery())
        engine.Use(middleware.Logger())
        engine.Use(middleware.CORS())

        // 注册路由
        router.SetupRouter(engine, cfg)

        // 注册Swagger
        if cfg.App.Mode != "release" </span><span class="cov0" title="0">{
                engine.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        }</span>


        // 创建HTTP服务器
        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:         fmt.Sprintf(":%d", cfg.App.Port),
                Handler:      engine,
                ReadTimeout:  time.Duration(cfg.App.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(cfg.App.WriteTimeout) * time.Second,
        }

        return &amp;Server{
                config: cfg,
                router: engine,
                server: server,
        }</span>
}

func (s *Server) Start() error <span class="cov0" title="0">{
        logger.Info(fmt.Sprintf("starting HTTP server on %s", s.server.Addr))
        return s.server.ListenAndServe()
}</span>

func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return s.server.Shutdown(ctx)
}</span>
</pre>

                <pre class="file" id="file12" style="display: none">package config

import (
        "fmt"
        "path/filepath"

        "github.com/spf13/viper"
)

type Config struct {
        App      *AppConfig      `mapstructure:"app"`
        Database *DatabaseConfig `mapstructure:"database"`
        Log      *LogConfig      `mapstructure:"log"`
        Minio    *MinioConfig    `mapstructure:"minio"`
        Platform *PlatformConfig `mapstructure:"platform"`
        Auth     *AuthConfig     `mapstructure:"auth"`
}

type AppConfig struct {
        Name         string `mapstructure:"name"`
        Version      string `mapstructure:"version"`
        Mode         string `mapstructure:"mode"`
        Port         int    `mapstructure:"port"`
        ReadTimeout  int    `mapstructure:"read_timeout"`
        WriteTimeout int    `mapstructure:"write_timeout"`
}

type DatabaseConfig struct {
        Default  string          `mapstructure:"default"`
        Postgres *PostgresConfig `mapstructure:"postgres"`
        Sqlite   *SqliteConfig   `mapstructure:"sqlite"`
}

type PostgresConfig struct {
        Host            string `mapstructure:"host"`
        Port            int    `mapstructure:"port"`
        User            string `mapstructure:"user"`
        Password        string `mapstructure:"password"`
        DBName          string `mapstructure:"dbname"`
        SSLMode         string `mapstructure:"sslmode"`
        MaxIdleConns    int    `mapstructure:"max_idle_conns"`
        MaxOpenConns    int    `mapstructure:"max_open_conns"`
        ConnMaxLifetime int    `mapstructure:"conn_max_lifetime"`
}

type SqliteConfig struct {
        Path        string `mapstructure:"path"`
        BusyTimeout int    `mapstructure:"busy_timeout"`
        ForeignKeys bool   `mapstructure:"foreign_keys"`
        JournalMode string `mapstructure:"journal_mode"`
}

type LogConfig struct {
        Level      string `mapstructure:"level"`
        Encoding   string `mapstructure:"encoding"`
        Output     string `mapstructure:"output"`
        MaxSize    int    `mapstructure:"max_size"`
        MaxBackups int    `mapstructure:"max_backups"`
        MaxAge     int    `mapstructure:"max_age"`
        Compress   bool   `mapstructure:"compress"`
}

type MinioConfig struct {
        Enabled    bool   `mapstructure:"enabled"`
        Endpoint   string `mapstructure:"endpoint"`
        AccessKey  string `mapstructure:"access_key"`
        SecretKey  string `mapstructure:"secret_key"`
        UseSSL     bool   `mapstructure:"use_ssl"`
        BucketName string `mapstructure:"bucket_name"`
        Region     string `mapstructure:"region"`
}

type PlatformConfig struct {
        Type string `mapstructure:"type"`
}

type AuthConfig struct {
        DESKey        string `mapstructure:"des_key"`
        JWTSecret     string `mapstructure:"jwt_secret"`
        JWTExpireHours int   `mapstructure:"jwt_expire_hours"`
}

var cfg *Config

func Init(configPath string) error <span class="cov0" title="0">{
        viper.SetConfigType("yaml")
        viper.SetConfigName(filepath.Base(configPath))
        viper.AddConfigPath(filepath.Dir(configPath))

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func Get() *Config <span class="cov0" title="0">{
        return cfg
}</span>
</pre>

                <pre class="file" id="file13" style="display: none">package impl

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type DeviceDAOImpl struct {
        db *gorm.DB
}

func NewDeviceDAO(db *gorm.DB) dao.DeviceDAO <span class="cov10" title="5">{
        return &amp;DeviceDAOImpl{db: db}
}</span>

func (d *DeviceDAOImpl) Create(ctx context.Context, device *entity.Device) error <span class="cov0" title="0">{
        logger.Info("creating device", zap.String("type", string(device.Type)))

        if err := d.db.WithContext(ctx).Create(device).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create device", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("device created successfully", zap.Uint("id", device.ID))
        return nil</span>
}

func (d *DeviceDAOImpl) Update(ctx context.Context, device *entity.Device) error <span class="cov1" title="1">{
        logger.Info("updating device", zap.Uint("id", device.ID))

        result := d.db.WithContext(ctx).Save(device)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update device", zap.Error(err), zap.Uint("id", device.ID))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("device not found for update", zap.Uint("id", device.ID))
                return errors.New("device not found")
        }</span>

        <span class="cov1" title="1">logger.Info("device updated successfully", zap.Uint("id", device.ID))
        return nil</span>
}

func (d *DeviceDAOImpl) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        logger.Info("deleting device", zap.Uint("id", id))

        result := d.db.WithContext(ctx).Delete(&amp;entity.Device{}, id)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete device", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("device not found for deletion", zap.Uint("id", id))
                return errors.New("device not found")
        }</span>

        <span class="cov1" title="1">logger.Info("device deleted successfully", zap.Uint("id", id))
        return nil</span>
}

func (d *DeviceDAOImpl) FindByID(ctx context.Context, id uint) (*entity.Device, error) <span class="cov7" title="3">{
        logger.Debug("finding device by id", zap.Uint("id", id))

        var device entity.Device
        err := d.db.WithContext(ctx).First(&amp;device, id).Error
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        logger.Debug("device not found", zap.Uint("id", id))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find device by id", zap.Error(err), zap.Uint("id", id))
                return nil, err</span>
        }

        <span class="cov4" title="2">logger.Debug("device found", zap.Uint("id", id))
        return &amp;device, nil</span>
}

func (d *DeviceDAOImpl) FindAll(ctx context.Context) ([]*entity.Device, error) <span class="cov1" title="1">{
        logger.Debug("finding all devices")

        var devices []*entity.Device
        err := d.db.WithContext(ctx).Find(&amp;devices).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find all devices", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found devices", zap.Int("count", len(devices)))
        return devices, nil</span>
}

// FindPage 分页查询设备
func (d *DeviceDAOImpl) FindPage(ctx context.Context, offset, limit int) ([]*entity.Device, int64, error) <span class="cov1" title="1">{
        logger.Debug("finding devices with pagination", zap.Int("offset", offset), zap.Int("limit", limit))

        var (
                devices []*entity.Device
                total   int64
        )

        db := d.db.WithContext(ctx).Model(&amp;entity.Device{})

        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to count devices for pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">if total == 0 </span><span class="cov0" title="0">{
                return []*entity.Device{}, 0, nil
        }</span>

        <span class="cov1" title="1">if err := db.Offset(offset).Limit(limit).Find(&amp;devices).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find devices with pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found devices with pagination", zap.Int("count", len(devices)), zap.Int64("total", total))
        return devices, total, nil</span>
}</pre>

                <pre class="file" id="file14" style="display: none">package impl

import (
        "context"
        "errors"

        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type PCDFileDAOImpl struct {
        db *gorm.DB
}

func NewPCDFileDAO(db *gorm.DB) dao.PCDFileDAO <span class="cov10" title="6">{
        return &amp;PCDFileDAOImpl{db: db}
}</span>

func (d *PCDFileDAOImpl) Create(ctx context.Context, file *entity.PCDFile) error <span class="cov0" title="0">{
        logger.Info("creating pcd file", zap.String("name", file.Name))

        if err := d.db.WithContext(ctx).Create(file).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create pcd file", zap.Error(err), zap.String("name", file.Name))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("pcd file created successfully", zap.Uint("id", file.ID), zap.String("name", file.Name))
        return nil</span>
}

func (d *PCDFileDAOImpl) Update(ctx context.Context, file *entity.PCDFile) error <span class="cov1" title="1">{
        logger.Info("updating pcd file", zap.Uint("id", file.ID))

        result := d.db.WithContext(ctx).Save(file)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update pcd file", zap.Error(err), zap.Uint("id", file.ID))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("pcd file not found for update", zap.Uint("id", file.ID))
                return errors.New("pcd file not found")
        }</span>

        <span class="cov1" title="1">logger.Info("pcd file updated successfully", zap.Uint("id", file.ID))
        return nil</span>
}

func (d *PCDFileDAOImpl) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        logger.Info("deleting pcd file", zap.Uint("id", id))

        result := d.db.WithContext(ctx).Delete(&amp;entity.PCDFile{}, id)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete pcd file", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("pcd file not found for deletion", zap.Uint("id", id))
                return errors.New("pcd file not found")
        }</span>

        <span class="cov1" title="1">logger.Info("pcd file deleted successfully", zap.Uint("id", id))
        return nil</span>
}

func (d *PCDFileDAOImpl) FindByID(ctx context.Context, id uint) (*entity.PCDFile, error) <span class="cov6" title="3">{
        logger.Debug("finding pcd file by id", zap.Uint("id", id))

        var file entity.PCDFile
        err := d.db.WithContext(ctx).First(&amp;file, id).Error
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        logger.Debug("pcd file not found", zap.Uint("id", id))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find pcd file by id", zap.Error(err), zap.Uint("id", id))
                return nil, err</span>
        }

        <span class="cov4" title="2">logger.Debug("pcd file found", zap.Uint("id", id))
        return &amp;file, nil</span>
}

func (d *PCDFileDAOImpl) FindAll(ctx context.Context) ([]*entity.PCDFile, error) <span class="cov1" title="1">{
        logger.Debug("finding all pcd files")

        var files []*entity.PCDFile
        err := d.db.WithContext(ctx).Find(&amp;files).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find all pcd files", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found pcd files", zap.Int("count", len(files)))
        return files, nil</span>
}

// FindByName 根据名称查询
func (d *PCDFileDAOImpl) FindByName(ctx context.Context, name string) (*entity.PCDFile, error) <span class="cov1" title="1">{
        logger.Debug("finding pcd file by name", zap.String("name", name))

        var file entity.PCDFile
        err := d.db.WithContext(ctx).Where("name = ?", name).First(&amp;file).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        logger.Debug("pcd file not found by name", zap.String("name", name))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find pcd file by name", zap.Error(err), zap.String("name", name))
                return nil, err</span>
        }

        <span class="cov1" title="1">logger.Debug("pcd file found by name", zap.String("name", name))
        return &amp;file, nil</span>
}

// FindPage 分页查询点云地图
func (d *PCDFileDAOImpl) FindPage(ctx context.Context, offset, limit int) ([]*entity.PCDFile, int64, error) <span class="cov1" title="1">{
        logger.Debug("finding pcd files with pagination", zap.Int("offset", offset), zap.Int("limit", limit))

        var (
                files []*entity.PCDFile
                total int64
        )

        db := d.db.WithContext(ctx).Model(&amp;entity.PCDFile{})

        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to count pcd files for pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">if total == 0 </span><span class="cov0" title="0">{
                return []*entity.PCDFile{}, 0, nil
        }</span>

        <span class="cov1" title="1">if err := db.Offset(offset).Limit(limit).Find(&amp;files).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find pcd files with pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found pcd files with pagination", zap.Int("count", len(files)), zap.Int64("total", total))
        return files, total, nil</span>
}
</pre>

                <pre class="file" id="file15" style="display: none">package impl

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type SemanticMapDAOImpl struct {
        db *gorm.DB
}

func NewSemanticMapDAO(db *gorm.DB) dao.SemanticMapDAO <span class="cov10" title="5">{
        return &amp;SemanticMapDAOImpl{db: db}
}</span>

func (d *SemanticMapDAOImpl) Create(ctx context.Context, semanticMap *entity.SemanticMap) error <span class="cov0" title="0">{
        logger.Info("creating semantic map")

        if err := d.db.WithContext(ctx).Create(semanticMap).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create semantic map", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("semantic map created successfully", zap.Uint("id", semanticMap.ID))
        return nil</span>
}

func (d *SemanticMapDAOImpl) Update(ctx context.Context, semanticMap *entity.SemanticMap) error <span class="cov1" title="1">{
        logger.Info("updating semantic map", zap.Uint("id", semanticMap.ID))

        result := d.db.WithContext(ctx).Save(semanticMap)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update semantic map", zap.Error(err), zap.Uint("id", semanticMap.ID))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("semantic map not found for update", zap.Uint("id", semanticMap.ID))
                return errors.New("semantic map not found")
        }</span>

        <span class="cov1" title="1">logger.Info("semantic map updated successfully", zap.Uint("id", semanticMap.ID))
        return nil</span>
}

func (d *SemanticMapDAOImpl) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        logger.Info("deleting semantic map", zap.Uint("id", id))

        result := d.db.WithContext(ctx).Delete(&amp;entity.SemanticMap{}, id)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete semantic map", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("semantic map not found for deletion", zap.Uint("id", id))
                return errors.New("semantic map not found")
        }</span>

        <span class="cov1" title="1">logger.Info("semantic map deleted successfully", zap.Uint("id", id))
        return nil</span>
}

func (d *SemanticMapDAOImpl) FindByID(ctx context.Context, id uint) (*entity.SemanticMap, error) <span class="cov7" title="3">{
        logger.Debug("finding semantic map by id", zap.Uint("id", id))

        var semanticMap entity.SemanticMap
        err := d.db.WithContext(ctx).Preload("PCDFile").First(&amp;semanticMap, id).Error
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        logger.Debug("semantic map not found", zap.Uint("id", id))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find semantic map by id", zap.Error(err), zap.Uint("id", id))
                return nil, err</span>
        }

        <span class="cov4" title="2">logger.Debug("semantic map found", zap.Uint("id", id))
        return &amp;semanticMap, nil</span>
}

func (d *SemanticMapDAOImpl) FindAll(ctx context.Context) ([]*entity.SemanticMap, error) <span class="cov1" title="1">{
        logger.Debug("finding all semantic maps")

        var semanticMaps []*entity.SemanticMap
        err := d.db.WithContext(ctx).Preload("PCDFile").Find(&amp;semanticMaps).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find all semantic maps", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found semantic maps", zap.Int("count", len(semanticMaps)))
        return semanticMaps, nil</span>
}

// FindPage 分页查询语义地图
func (d *SemanticMapDAOImpl) FindPage(ctx context.Context, offset, limit int) ([]*entity.SemanticMap, int64, error) <span class="cov1" title="1">{
        logger.Debug("finding semantic maps with pagination", zap.Int("offset", offset), zap.Int("limit", limit))

        var (
                semanticMaps []*entity.SemanticMap
                total        int64
        )

        db := d.db.WithContext(ctx).Model(&amp;entity.SemanticMap{}).Preload("PCDFile")

        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to count semantic maps for pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">if total == 0 </span><span class="cov0" title="0">{
                return []*entity.SemanticMap{}, 0, nil
        }</span>

        <span class="cov1" title="1">if err := db.Offset(offset).Limit(limit).Find(&amp;semanticMaps).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find semantic maps with pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found semantic maps with pagination", zap.Int("count", len(semanticMaps)), zap.Int64("total", total))
        return semanticMaps, total, nil</span>
}</pre>

                <pre class="file" id="file16" style="display: none">package impl

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type TaskDAOImpl struct {
        db *gorm.DB
}

func NewTaskDAO(db *gorm.DB) dao.TaskDAO <span class="cov10" title="5">{
        return &amp;TaskDAOImpl{db: db}
}</span>

func (d *TaskDAOImpl) Create(ctx context.Context, task *entity.Task) error <span class="cov0" title="0">{
        logger.Info("creating task")

        if err := d.db.WithContext(ctx).Create(task).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create task", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("task created successfully", zap.Uint("id", task.ID))
        return nil</span>
}

func (d *TaskDAOImpl) Update(ctx context.Context, task *entity.Task) error <span class="cov1" title="1">{
        logger.Info("updating task", zap.Uint("id", task.ID))

        result := d.db.WithContext(ctx).Save(task)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update task", zap.Error(err), zap.Uint("id", task.ID))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("task not found for update", zap.Uint("id", task.ID))
                return errors.New("task not found")
        }</span>

        <span class="cov1" title="1">logger.Info("task updated successfully", zap.Uint("id", task.ID))
        return nil</span>
}

func (d *TaskDAOImpl) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        logger.Info("deleting task", zap.Uint("id", id))

        result := d.db.WithContext(ctx).Delete(&amp;entity.Task{}, id)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete task", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("task not found for deletion", zap.Uint("id", id))
                return errors.New("task not found")
        }</span>

        <span class="cov1" title="1">logger.Info("task deleted successfully", zap.Uint("id", id))
        return nil</span>
}

func (d *TaskDAOImpl) FindByID(ctx context.Context, id uint) (*entity.Task, error) <span class="cov7" title="3">{
        logger.Debug("finding task by id", zap.Uint("id", id))

        var task entity.Task
        err := d.db.WithContext(ctx).Preload("SemanticMap.PCDFile").First(&amp;task, id).Error
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        logger.Debug("task not found", zap.Uint("id", id))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find task by id", zap.Error(err), zap.Uint("id", id))
                return nil, err</span>
        }

        <span class="cov4" title="2">logger.Debug("task found", zap.Uint("id", id))
        return &amp;task, nil</span>
}

func (d *TaskDAOImpl) FindAll(ctx context.Context) ([]*entity.Task, error) <span class="cov1" title="1">{
        logger.Debug("finding all tasks")

        var tasks []*entity.Task
        err := d.db.WithContext(ctx).Preload("SemanticMap.PCDFile").Find(&amp;tasks).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find all tasks", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found tasks", zap.Int("count", len(tasks)))
        return tasks, nil</span>
}

// FindPage 分页查询任务
func (d *TaskDAOImpl) FindPage(ctx context.Context, offset, limit int) ([]*entity.Task, int64, error) <span class="cov1" title="1">{
        logger.Debug("finding tasks with pagination", zap.Int("offset", offset), zap.Int("limit", limit))

        var (
                tasks []*entity.Task
                total int64
        )

        db := d.db.WithContext(ctx).Model(&amp;entity.Task{}).Preload("SemanticMap.PCDFile")

        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to count tasks for pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">if total == 0 </span><span class="cov0" title="0">{
                return []*entity.Task{}, 0, nil
        }</span>

        <span class="cov1" title="1">if err := db.Offset(offset).Limit(limit).Find(&amp;tasks).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find tasks with pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found tasks with pagination", zap.Int("count", len(tasks)), zap.Int64("total", total))
        return tasks, total, nil</span>
}</pre>

                <pre class="file" id="file17" style="display: none">package impl

import (
        "context"
        "errors"

        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type UserDAOImpl struct {
        db *gorm.DB
}

func NewUserDAO(db *gorm.DB) dao.UserDAO <span class="cov10" title="8">{
        return &amp;UserDAOImpl{db: db}
}</span>

func (d *UserDAOImpl) Create(ctx context.Context, user *entity.UserInfo) error <span class="cov1" title="1">{
        logger.Info("creating user", zap.String("username", user.UserName))

        if err := d.db.WithContext(ctx).Create(user).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create user", zap.Error(err), zap.Any("user", user))
                return err
        }</span>

        <span class="cov1" title="1">logger.Info("user created successfully", zap.Uint("id", user.ID), zap.String("username", user.UserName))
        return nil</span>
}

func (d *UserDAOImpl) Update(ctx context.Context, user *entity.UserInfo) error <span class="cov1" title="1">{
        logger.Info("updating user", zap.Uint("id", user.ID))

        result := d.db.WithContext(ctx).Save(user)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update user", zap.Error(err), zap.Uint("id", user.ID))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("user not found for update", zap.Uint("id", user.ID))
                return errors.New("user not found")
        }</span>

        <span class="cov1" title="1">logger.Info("user updated successfully", zap.Uint("id", user.ID))
        return nil</span>
}

func (d *UserDAOImpl) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        logger.Info("deleting user", zap.Uint("id", id))

        result := d.db.WithContext(ctx).Delete(&amp;entity.UserInfo{}, id)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete user", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("user not found for deletion", zap.Uint("id", id))
                return errors.New("user not found")
        }</span>

        <span class="cov1" title="1">logger.Info("user deleted successfully", zap.Uint("id", id))
        return nil</span>
}

func (d *UserDAOImpl) FindByID(ctx context.Context, id uint) (*entity.UserInfo, error) <span class="cov7" title="5">{
        logger.Debug("finding user by id", zap.Uint("id", id))

        var user entity.UserInfo
        err := d.db.WithContext(ctx).First(&amp;user, id).Error
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov4" title="2">{
                        logger.Debug("user not found", zap.Uint("id", id))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find user by id", zap.Error(err), zap.Uint("id", id))
                return nil, err</span>
        }

        <span class="cov5" title="3">logger.Debug("user found", zap.Uint("id", id))
        return &amp;user, nil</span>
}

func (d *UserDAOImpl) FindAll(ctx context.Context) ([]*entity.UserInfo, error) <span class="cov1" title="1">{
        logger.Debug("finding all users")

        var users []*entity.UserInfo
        err := d.db.WithContext(ctx).Find(&amp;users).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find all users", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found users", zap.Int("count", len(users)))
        return users, nil</span>
}

// FindPage 分页查询用户
func (d *UserDAOImpl) FindPage(ctx context.Context, offset, limit int) ([]*entity.UserInfo, int64, error) <span class="cov4" title="2">{
        logger.Debug("finding users with pagination", zap.Int("offset", offset), zap.Int("limit", limit))

        var (
                users []*entity.UserInfo
                total int64
        )

        db := d.db.WithContext(ctx).Model(&amp;entity.UserInfo{})

        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to count users for pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov4" title="2">if total == 0 </span><span class="cov0" title="0">{
                return []*entity.UserInfo{}, 0, nil
        }</span>

        <span class="cov4" title="2">if err := db.Offset(offset).Limit(limit).Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find users with pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov4" title="2">logger.Debug("found users with pagination", zap.Int("count", len(users)), zap.Int64("total", total))
        return users, total, nil</span>
}

func (d *UserDAOImpl) FindByUserName(ctx context.Context, userName string) (*entity.UserInfo, error) <span class="cov1" title="1">{
        logger.Debug("finding user by username", zap.String("username", userName))

        var user entity.UserInfo
        err := d.db.WithContext(ctx).Where("user_name = ?", userName).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        logger.Debug("user not found by username", zap.String("username", userName))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find user by username", zap.Error(err), zap.String("username", userName))
                return nil, err</span>
        }

        <span class="cov1" title="1">logger.Debug("user found by username", zap.String("username", userName))
        return &amp;user, nil</span>
}</pre>

                <pre class="file" id="file18" style="display: none">package impl

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"

        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type UserOperationDAOImpl struct {
        db *gorm.DB
}

func NewUserOperationDAO(db *gorm.DB) dao.UserOperationDAO <span class="cov10" title="5">{
        return &amp;UserOperationDAOImpl{db: db}
}</span>

func (d *UserOperationDAOImpl) Create(ctx context.Context, operation *entity.UserOperation) error <span class="cov0" title="0">{
        logger.Info("creating operation record", zap.String("username", operation.UserName))

        if err := d.db.WithContext(ctx).Create(operation).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create operation record", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("operation record created successfully", zap.Uint("id", operation.ID))
        return nil</span>
}

func (d *UserOperationDAOImpl) Update(ctx context.Context, operation *entity.UserOperation) error <span class="cov1" title="1">{
        logger.Info("updating operation record", zap.Uint("id", operation.ID))

        result := d.db.WithContext(ctx).Save(operation)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update operation record", zap.Error(err), zap.Uint("id", operation.ID))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("operation record not found for update", zap.Uint("id", operation.ID))
                return errors.New("operation record not found")
        }</span>

        <span class="cov1" title="1">logger.Info("operation record updated successfully", zap.Uint("id", operation.ID))
        return nil</span>
}

func (d *UserOperationDAOImpl) Delete(ctx context.Context, id uint) error <span class="cov1" title="1">{
        logger.Info("deleting operation record", zap.Uint("id", id))

        result := d.db.WithContext(ctx).Delete(&amp;entity.UserOperation{}, id)
        if err := result.Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete operation record", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov1" title="1">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                logger.Warn("operation record not found for deletion", zap.Uint("id", id))
                return errors.New("operation record not found")
        }</span>

        <span class="cov1" title="1">logger.Info("operation record deleted successfully", zap.Uint("id", id))
        return nil</span>
}

func (d *UserOperationDAOImpl) FindByID(ctx context.Context, id uint) (*entity.UserOperation, error) <span class="cov7" title="3">{
        logger.Debug("finding operation record by id", zap.Uint("id", id))

        var operation entity.UserOperation
        err := d.db.WithContext(ctx).First(&amp;operation, id).Error
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        logger.Debug("operation record not found", zap.Uint("id", id))
                        return nil, nil
                }</span>
                <span class="cov0" title="0">logger.Error("failed to find operation record by id", zap.Error(err), zap.Uint("id", id))
                return nil, err</span>
        }

        <span class="cov4" title="2">logger.Debug("operation record found", zap.Uint("id", id))
        return &amp;operation, nil</span>
}

func (d *UserOperationDAOImpl) FindAll(ctx context.Context) ([]*entity.UserOperation, error) <span class="cov1" title="1">{
        logger.Debug("finding all operation records")

        var operations []*entity.UserOperation
        err := d.db.WithContext(ctx).Order("create_time desc").Find(&amp;operations).Error
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find all operation records", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found operation records", zap.Int("count", len(operations)))
        return operations, nil</span>
}

// FindPage 分页查询操作记录
func (d *UserOperationDAOImpl) FindPage(ctx context.Context, offset, limit int) ([]*entity.UserOperation, int64, error) <span class="cov1" title="1">{
        logger.Debug("finding operation records with pagination", zap.Int("offset", offset), zap.Int("limit", limit))

        var (
                operations []*entity.UserOperation
                total      int64
        )

        db := d.db.WithContext(ctx).Model(&amp;entity.UserOperation{})

        if err := db.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to count operation records for pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">if total == 0 </span><span class="cov0" title="0">{
                return []*entity.UserOperation{}, 0, nil
        }</span>

        <span class="cov1" title="1">if err := db.Order("create_time desc").Offset(offset).Limit(limit).Find(&amp;operations).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find operation records with pagination", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">logger.Debug("found operation records with pagination", zap.Int("count", len(operations)), zap.Int64("total", total))
        return operations, total, nil</span>
}</pre>

                <pre class="file" id="file19" style="display: none">package database

import (
        "fmt"
        "os"
        "path/filepath"

        "robot_scheduler/internal/config"
        "robot_scheduler/internal/logger"

        "time"

        "gorm.io/driver/postgres"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        gormLogger "gorm.io/gorm/logger"
)

var DB *gorm.DB

func Init(cfg *config.Config) error <span class="cov0" title="0">{
        var dialector gorm.Dialector
        var err error

        switch cfg.Database.Default </span>{
        case "postgres":<span class="cov0" title="0">
                dialector, err = initPostgres(cfg.Database.Postgres)</span>
        case "sqlite":<span class="cov0" title="0">
                dialector, err = initSqlite(cfg.Database.Sqlite)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database type: %s", cfg.Database.Default)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 创建GORM配置
        <span class="cov0" title="0">gormConfig := &amp;gorm.Config{
                Logger: gormLogger.Default.LogMode(gormLogger.Info),
        }

        // 连接数据库
        DB, err = gorm.Open(dialector, gormConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // 获取通用数据库对象
        <span class="cov0" title="0">sqlDB, err := DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 设置连接池
        <span class="cov0" title="0">if cfg.Database.Default == "postgres" &amp;&amp; cfg.Database.Postgres != nil </span><span class="cov0" title="0">{
                sqlDB.SetMaxIdleConns(cfg.Database.Postgres.MaxIdleConns)
                sqlDB.SetMaxOpenConns(cfg.Database.Postgres.MaxOpenConns)
                sqlDB.SetConnMaxLifetime(time.Duration(cfg.Database.Postgres.ConnMaxLifetime) * time.Second)
        }</span>

        <span class="cov0" title="0">logger.Info(fmt.Sprintf("connected to %s database", cfg.Database.Default))
        return nil</span>
}

func initPostgres(cfg *config.PostgresConfig) (gorm.Dialector, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("postgres config is nil")
        }</span>

        <span class="cov0" title="0">dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode)

        return postgres.Open(dsn), nil</span>
}

func initSqlite(cfg *config.SqliteConfig) (gorm.Dialector, error) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sqlite config is nil")
        }</span>

        // 创建数据目录
        <span class="cov0" title="0">dir := filepath.Dir(cfg.Path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config := &amp;sqlite.Config{
                DriverName: "sqlite3",
                DSN:        cfg.Path + "?" + buildSqliteParams(cfg),
        }

        return sqlite.Open(config.DSN), nil</span>
}

func buildSqliteParams(cfg *config.SqliteConfig) string <span class="cov0" title="0">{
        params := ""
        if cfg.BusyTimeout &gt; 0 </span><span class="cov0" title="0">{
                params += fmt.Sprintf("_busy_timeout=%d&amp;", cfg.BusyTimeout)
        }</span>
        <span class="cov0" title="0">if !cfg.ForeignKeys </span><span class="cov0" title="0">{
                params += "_foreign_keys=off&amp;"
        }</span>
        <span class="cov0" title="0">if cfg.JournalMode != "" </span><span class="cov0" title="0">{
                params += fmt.Sprintf("_journal_mode=%s&amp;", cfg.JournalMode)
        }</span>
        <span class="cov0" title="0">return params</span>
}
</pre>

                <pre class="file" id="file20" style="display: none">package logger

import (
        "os"
        "path/filepath"
        "robot_scheduler/internal/config"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
)

var Logger *zap.Logger

func Init(config *config.LogConfig) error <span class="cov0" title="0">{
        // 创建日志目录
        logDir := filepath.Dir(config.Output)
        if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 设置日志级别
        <span class="cov0" title="0">var level zapcore.Level
        if err := level.UnmarshalText([]byte(config.Level)); err != nil </span><span class="cov0" title="0">{
                level = zapcore.InfoLevel
        }</span>

        // 编码器配置
        <span class="cov0" title="0">encoderConfig := zapcore.EncoderConfig{
                TimeKey:       "time",
                LevelKey:      "level",
                NameKey:       "logger",
                CallerKey:     "caller",
                MessageKey:    "msg",
                StacktraceKey: "stacktrace",
                LineEnding:    zapcore.DefaultLineEnding,
                EncodeLevel:   zapcore.LowercaseLevelEncoder,
                EncodeTime: func(t time.Time, enc zapcore.PrimitiveArrayEncoder) </span><span class="cov0" title="0">{
                        enc.AppendString(t.Format("2006-01-02 15:04:05.000"))
                }</span>,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        // 编码器
        <span class="cov0" title="0">var encoder zapcore.Encoder
        if config.Encoding == "console" </span><span class="cov0" title="0">{
                encoder = zapcore.NewConsoleEncoder(encoderConfig)
        }</span> else<span class="cov0" title="0"> {
                encoder = zapcore.NewJSONEncoder(encoderConfig)
        }</span>

        // 日志写入器
        <span class="cov0" title="0">writer := zapcore.AddSync(&amp;lumberjack.Logger{
                Filename:   config.Output,
                MaxSize:    config.MaxSize,
                MaxBackups: config.MaxBackups,
                MaxAge:     config.MaxAge,
                Compress:   config.Compress,
        })

        // 核心配置
        core := zapcore.NewCore(
                encoder,
                zapcore.NewMultiWriteSyncer(writer, zapcore.AddSync(os.Stdout)),
                level,
        )

        // 创建Logger
        Logger = zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))

        return nil</span>
}

func Sync() error <span class="cov0" title="0">{
        return Logger.Sync()
}</span>

// 快捷方法
func Debug(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Logger.Debug(msg, fields...)
}</span>

func Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Sugar().Debugf(format, args...)
}</span>

func Info(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Logger.Info(msg, fields...)
}</span>

func Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Sugar().Infof(format, args...)
}</span>

func Warn(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Logger.Warn(msg, fields...)
}</span>

func Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Sugar().Warnf(format, args...)
}</span>

func Error(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Logger.Error(msg, fields...)
}</span>

func Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Sugar().Errorf(format, args...)
}</span>

func DPanic(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Logger.DPanic(msg, fields...)
}</span>

func DPanicf(format string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Sugar().DPanicf(format, args...)
}</span>

func Panic(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Logger.Panic(msg, fields...)
}</span>

func Panicf(format string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Sugar().Panicf(format, args...)
}</span>

func Fatal(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        Logger.Fatal(msg, fields...)
}</span>

func Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Sugar().Fatalf(format, args...)
}</span>
</pre>

                <pre class="file" id="file21" style="display: none">package minio_client

import (
        "robot_scheduler/internal/config"

        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
)

var client *minio.Client

// Init 初始化 MinIO 客户端
func Init(cfg *config.MinioConfig) error <span class="cov10" title="2">{
        if cfg == nil || !cfg.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov10" title="2">c, err := minio.New(cfg.Endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(cfg.AccessKey, cfg.SecretKey, ""),
                Secure: cfg.UseSSL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="2">client = c
        return nil</span>
}

// Client 获取全局 MinIO 客户端
func Client() *minio.Client <span class="cov10" title="2">{
        return client
}</span>
</pre>

                <pre class="file" id="file22" style="display: none">package dto

import (
        "robot_scheduler/internal/model/entity"
        "time"
)

// DeviceCreateRequest 创建设备请求
type DeviceCreateRequest struct {
        Type      entity.DeviceType  `json:"type" binding:"required"`    // 设备类型
        Company   entity.CompanyType `json:"company" binding:"required"` // 设备厂商
        IP        *string            `json:"ip,omitempty"`               // 设备IP
        Port      int                `json:"port" binding:"required"`    // 设备端口
        UserName  *string            `json:"userName,omitempty"`         // 登录用户名
        Password  *string            `json:"password,omitempty"`         // 登录密码
        ExtraInfo *string            `json:"extraInfo,omitempty"`        // 扩展信息
}

// DeviceUpdateRequest 更新设备请求
type DeviceUpdateRequest struct {
        Type      *entity.DeviceType   `json:"type,omitempty"`      // 设备类型
        Company   *entity.CompanyType  `json:"company,omitempty"`   // 设备厂商
        IP        *string              `json:"ip,omitempty"`        // 设备IP
        Port      *int                 `json:"port,omitempty"`      // 设备端口
        UserName  *string              `json:"userName,omitempty"`  // 登录用户名
        Password  *string              `json:"password,omitempty"`  // 登录密码
        Status    *entity.DeviceStatus `json:"status,omitempty"`    // 设备状态
        ExtraInfo *string              `json:"extraInfo,omitempty"` // 扩展信息
}

// DeviceResponse 设备响应
type DeviceResponse struct {
        ID         uint                 `json:"id"`                  // 设备ID
        Type       entity.DeviceType    `json:"type"`                // 设备类型
        Company    entity.CompanyType   `json:"company"`             // 设备厂商
        IP         *string              `json:"ip,omitempty"`        // 设备IP
        Port       int                  `json:"port"`                // 设备端口
        UserName   *string              `json:"userName,omitempty"`  // 登录用户名
        Status     *entity.DeviceStatus `json:"status"`              // 设备状态
        CreateTime *time.Time           `json:"createTime"`          // 创建时间
        UpdateTime *time.Time           `json:"updateTime"`          // 更新时间
        ExtraInfo  *string              `json:"extraInfo,omitempty"` // 扩展信息
}

// DeviceListResponse 设备列表响应
type DeviceListResponse struct {
        PageResponse
        List []*DeviceResponse `json:"list"` // 设备列表
}

// NewDeviceResponseFromEntity 从实体对象构建设备响应
func NewDeviceResponseFromEntity(d *entity.Device) *DeviceResponse <span class="cov0" title="0">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;DeviceResponse{
                ID:         d.ID,
                Type:       d.Type,
                Company:    d.Company,
                IP:         d.IP,
                Port:       d.Port,
                UserName:   d.UserName,
                Status:     d.Status,
                CreateTime: &amp;d.CreatedAt,
                UpdateTime: &amp;d.UpdatedAt,
                ExtraInfo:  d.ExtraInfo,
        }</span>
}

// NewDeviceListResponseFromEntities 从实体列表构建设备列表响应
func NewDeviceListResponseFromEntities(list []*entity.Device, page PageResponse) *DeviceListResponse <span class="cov0" title="0">{
        resp := &amp;DeviceListResponse{
                PageResponse: page,
                List:         make([]*DeviceResponse, 0, len(list)),
        }
        for _, d := range list </span><span class="cov0" title="0">{
                resp.List = append(resp.List, NewDeviceResponseFromEntity(d))
        }</span>
        <span class="cov0" title="0">return resp</span>
}</pre>

                <pre class="file" id="file23" style="display: none">package dto

import (
        "robot_scheduler/internal/model/entity"
        "time"
)

// PCDFileCreateRequest 创建点云地图请求
type PCDFileCreateRequest struct {
        Name      string  `json:"name" binding:"required,min=1,max=100"` // 地图名称
        Area      string  `json:"area" binding:"required"`               // 区域描述
        Path      string  `json:"path" binding:"required"`               // 文件存储路径
        UserName  string  `json:"userName" binding:"required"`           // 上传人员
        Size      int     `json:"size" binding:"required,min=0"`         // 文件大小
        MinioPath *string `json:"minioPath,omitempty"`                   // MinIO存储路径
        ExtraInfo *string `json:"extraInfo,omitempty"`                   // 扩展信息
}

// PCDFileUpdateRequest 更新点云地图请求
type PCDFileUpdateRequest struct {
        Name      *string `json:"name,omitempty" binding:"omitempty,min=1,max=100"` // 地图名称
        Area      *string `json:"area,omitempty"`                                   // 区域描述
        Path      *string `json:"path,omitempty"`                                   // 文件存储路径
        UserName  *string `json:"userName,omitempty"`                               // 上传人员
        Size      *int    `json:"size,omitempty" binding:"omitempty,min=0"`         // 文件大小
        MinioPath *string `json:"minioPath,omitempty"`                              // MinIO存储路径
        ExtraInfo *string `json:"extraInfo,omitempty"`                              // 扩展信息
}

// PCDFileResponse 点云地图响应
type PCDFileResponse struct {
        ID         uint       `json:"id"`                  // 地图ID
        Name       string     `json:"name"`                // 地图名称
        Area       string     `json:"area"`                // 区域描述
        Path       string     `json:"path"`                // 文件存储路径
        UserName   string     `json:"userName"`            // 上传人员
        Size       int        `json:"size"`                // 文件大小
        MinioPath  *string    `json:"minioPath,omitempty"` // MinIO存储路径
        CreateTime *time.Time `json:"createTime"`          // 创建时间
        UpdateTime *time.Time `json:"updateTime"`          // 更新时间
        ExtraInfo  *string    `json:"extraInfo,omitempty"` // 扩展信息
}

// PCDFileListResponse 点云地图列表响应
type PCDFileListResponse struct {
        PageResponse
        List []*PCDFileResponse `json:"list"` // 点云地图列表
}

// NewPCDFileResponseFromEntity 从实体对象构建点云地图响应
func NewPCDFileResponseFromEntity(f *entity.PCDFile) *PCDFileResponse <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PCDFileResponse{
                ID:         f.ID,
                Name:       f.Name,
                Area:       f.Area,
                Path:       f.Path,
                UserName:   f.UserName,
                Size:       f.Size,
                MinioPath:  f.MinioPath,
                CreateTime: &amp;f.CreatedAt,
                UpdateTime: &amp;f.UpdatedAt,
                ExtraInfo:  f.ExtraInfo,
        }</span>
}

// NewPCDFileListResponseFromEntities 从实体列表构建点云地图列表响应
func NewPCDFileListResponseFromEntities(list []*entity.PCDFile, page PageResponse) *PCDFileListResponse <span class="cov0" title="0">{
        resp := &amp;PCDFileListResponse{
                PageResponse: page,
                List:         make([]*PCDFileResponse, 0, len(list)),
        }
        for _, f := range list </span><span class="cov0" title="0">{
                resp.List = append(resp.List, NewPCDFileResponseFromEntity(f))
        }</span>
        <span class="cov0" title="0">return resp</span>
}
</pre>

                <pre class="file" id="file24" style="display: none">package dto

import (
        "robot_scheduler/internal/model/entity"
        "time"
)

// SemanticMapCreateRequest 创建语义地图请求
type SemanticMapCreateRequest struct {
        PCDFileID    uint    `json:"pcdFileId" binding:"required"`    // 对应的pcd地图文件id
        UserName     string  `json:"userName" binding:"required"`     // 编辑人员
        SemanticInfo string  `json:"semanticInfo" binding:"required"` // 语义信息
        ExtraInfo    *string `json:"extraInfo,omitempty"`             // 扩展信息
}

// SemanticMapUpdateRequest 更新语义地图请求
type SemanticMapUpdateRequest struct {
        PCDFileID    *uint   `json:"pcdFileId,omitempty"`    // 对应的pcd地图文件id
        UserName     *string `json:"userName,omitempty"`     // 编辑人员
        SemanticInfo *string `json:"semanticInfo,omitempty"` // 语义信息
        ExtraInfo    *string `json:"extraInfo,omitempty"`    // 扩展信息
}

// SemanticMapResponse 语义地图响应
type SemanticMapResponse struct {
        ID           uint            `json:"id"`                  // 语义地图ID
        PCDFileID    uint            `json:"pcdFileId"`           // 对应的pcd地图文件id
        PCDFile      *entity.PCDFile `json:"pcdFile,omitempty"`   // 关联的点云地图
        UserName     string          `json:"userName"`            // 编辑人员
        SemanticInfo string          `json:"semanticInfo"`        // 语义信息
        CreateTime   *time.Time      `json:"createTime"`          // 创建时间
        UpdateTime   *time.Time      `json:"updateTime"`          // 更新时间
        ExtraInfo    *string         `json:"extraInfo,omitempty"` // 扩展信息
}

// SemanticMapListResponse 语义地图列表响应
type SemanticMapListResponse struct {
        PageResponse
        List []*SemanticMapResponse `json:"list"` // 语义地图列表
}

// NewSemanticMapResponseFromEntity 从实体对象构建语义地图响应
func NewSemanticMapResponseFromEntity(m *entity.SemanticMap) *SemanticMapResponse <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;SemanticMapResponse{
                ID:           m.ID,
                PCDFileID:    m.PCDFileID,
                PCDFile:      &amp;m.PCDFile,
                UserName:     m.UserName,
                SemanticInfo: m.SemanticInfo,
                CreateTime:   &amp;m.CreatedAt,
                UpdateTime:   &amp;m.UpdatedAt,
                ExtraInfo:    m.ExtraInfo,
        }</span>
}

// NewSemanticMapListResponseFromEntities 从实体列表构建语义地图列表响应
func NewSemanticMapListResponseFromEntities(list []*entity.SemanticMap, page PageResponse) *SemanticMapListResponse <span class="cov0" title="0">{
        resp := &amp;SemanticMapListResponse{
                PageResponse: page,
                List:         make([]*SemanticMapResponse, 0, len(list)),
        }
        for _, m := range list </span><span class="cov0" title="0">{
                resp.List = append(resp.List, NewSemanticMapResponseFromEntity(m))
        }</span>
        <span class="cov0" title="0">return resp</span>
}</pre>

                <pre class="file" id="file25" style="display: none">package dto

import (
        "robot_scheduler/internal/model/entity"
        "time"
)

// TaskCreateRequest 创建任务请求
type TaskCreateRequest struct {
        SemanticMapID uint    `json:"semanticMapId" binding:"required"` // 对应的语义地图id
        UserName      string  `json:"userName" binding:"required"`      // 编辑人员
        TaskInfo      string  `json:"taskInfo" binding:"required"`      // 任务信息
        ExtraInfo     *string `json:"extraInfo,omitempty"`              // 扩展信息
}

// TaskUpdateRequest 更新任务请求
type TaskUpdateRequest struct {
        SemanticMapID *uint              `json:"semanticMapId,omitempty"` // 对应的语义地图id
        UserName      *string            `json:"userName,omitempty"`      // 编辑人员
        TaskInfo      *string            `json:"taskInfo,omitempty"`      // 任务信息
        Status        *entity.TaskStatus `json:"status,omitempty"`        // 任务状态
        ExtraInfo     *string            `json:"extraInfo,omitempty"`     // 扩展信息
}

// TaskResponse 任务响应
type TaskResponse struct {
        ID            uint                `json:"id"`                    // 任务ID
        SemanticMapID uint                `json:"semanticMapId"`         // 对应的语义地图id
        SemanticMap   *entity.SemanticMap `json:"semanticMap,omitempty"` // 关联的语义地图
        UserName      string              `json:"userName"`              // 编辑人员
        TaskInfo      string              `json:"taskInfo"`              // 任务信息
        Status        *entity.TaskStatus  `json:"status"`                // 任务状态
        CreateTime    *time.Time          `json:"createTime"`            // 创建时间
        UpdateTime    *time.Time          `json:"updateTime"`            // 更新时间
        ExtraInfo     *string             `json:"extraInfo,omitempty"`   // 扩展信息
}

// TaskListResponse 任务列表响应
type TaskListResponse struct {
        PageResponse
        List []*TaskResponse `json:"list"` // 任务列表
}

// NewTaskResponseFromEntity 从实体对象构建任务响应
func NewTaskResponseFromEntity(t *entity.Task) *TaskResponse <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;TaskResponse{
                ID:            t.ID,
                SemanticMapID: t.SemanticMapID,
                SemanticMap:   &amp;t.SemanticMap,
                UserName:      t.UserName,
                TaskInfo:      t.TaskInfo,
                Status:        t.Status,
                CreateTime:    &amp;t.CreatedAt,
                UpdateTime:    &amp;t.UpdatedAt,
                ExtraInfo:     t.ExtraInfo,
        }</span>
}

// NewTaskListResponseFromEntities 从实体列表构建任务列表响应
func NewTaskListResponseFromEntities(list []*entity.Task, page PageResponse) *TaskListResponse <span class="cov0" title="0">{
        resp := &amp;TaskListResponse{
                PageResponse: page,
                List:         make([]*TaskResponse, 0, len(list)),
        }
        for _, t := range list </span><span class="cov0" title="0">{
                resp.List = append(resp.List, NewTaskResponseFromEntity(t))
        }</span>
        <span class="cov0" title="0">return resp</span>
}</pre>

                <pre class="file" id="file26" style="display: none">package dto

import (
        "robot_scheduler/internal/model/entity"
        "time"
)

// UserCreateRequest 创建用户请求
type UserCreateRequest struct {
        UserName  string          `json:"userName" binding:"required,min=3,max=50"`                          // 用户名
        Password  string          `json:"password" binding:"required,min=6"`                                 // 密码
        Role      entity.RoleType `json:"role" binding:"required,oneof=administrator manager operator user"` // 角色
        ExtraInfo *string         `json:"extraInfo,omitempty"`                                               // 扩展信息
}

// UserUpdateRequest 更新用户请求
type UserUpdateRequest struct {
        Password  *string          `json:"password,omitempty"`                     // 密码
        Role      *entity.RoleType `json:"role,omitempty"`                         // 角色
        IsLocked  *int             `json:"isLocked,omitempty" binding:"oneof=0 1"` // 是否锁定
        ExtraInfo *string          `json:"extraInfo,omitempty"`                    // 扩展信息
}

// UserResponse 用户响应
type UserResponse struct {
        ID         uint            `json:"id"`                  // 用户ID
        UserName   string          `json:"userName"`            // 用户名
        Role       entity.RoleType `json:"role"`                // 角色
        IsLocked   int             `json:"isLocked"`            // 是否锁定
        CreateTime *time.Time      `json:"createTime"`          // 创建时间
        UpdateTime *time.Time      `json:"updateTime"`          // 更新时间
        ExtraInfo  *string         `json:"extraInfo,omitempty"` // 扩展信息
}

// UserListResponse 用户列表响应
type UserListResponse struct {
        PageResponse
        List []*UserResponse `json:"list"` // 用户列表
}

// NewUserResponseFromEntity 从实体对象构建用户响应
func NewUserResponseFromEntity(u *entity.UserInfo) *UserResponse <span class="cov0" title="0">{
        if u == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;UserResponse{
                ID:         u.ID,
                UserName:   u.UserName,
                Role:       u.Role,
                IsLocked:   u.IsLocked,
                CreateTime: &amp;u.CreatedAt,
                UpdateTime: &amp;u.UpdatedAt,
                ExtraInfo:  u.ExtraInfo,
        }</span>
}

// NewUserListResponseFromEntities 从实体列表构建用户列表响应
// 分页信息由调用方填充 PageResponse 字段
func NewUserListResponseFromEntities(list []*entity.UserInfo, page PageResponse) *UserListResponse <span class="cov0" title="0">{
        resp := &amp;UserListResponse{
                PageResponse: page,
                List:         make([]*UserResponse, 0, len(list)),
        }
        for _, u := range list </span><span class="cov0" title="0">{
                resp.List = append(resp.List, NewUserResponseFromEntity(u))
        }</span>
        <span class="cov0" title="0">return resp</span>
}

// LoginRequest 登录请求
type LoginRequest struct {
        UserName string `json:"userName" binding:"required"` // 用户名
        Password string `json:"password" binding:"required"` // 密码
}

// LoginResponse 登录响应
type LoginResponse struct {
        Token string       `json:"token"` // JWT token
        User  *UserResponse `json:"user"`  // 用户信息
}</pre>

                <pre class="file" id="file27" style="display: none">package dto

import (
        "robot_scheduler/internal/model/entity"
        "time"
)

// UserOperationCreateRequest 创建操作记录请求
type UserOperationCreateRequest struct {
        UserName   string               `json:"userName" binding:"required"`  // 操作人员
        Operation  entity.OperationType `json:"operation" binding:"required"` // 操作类型
        Module     string               `json:"module" binding:"required"`    // 操作模块
        TargetID   *uint                `json:"targetId,omitempty"`           // 目标ID
        TargetName *string              `json:"targetName,omitempty"`         // 目标名称
        IP         *string              `json:"ip,omitempty"`                 // 操作IP
        UserAgent  *string              `json:"userAgent,omitempty"`          // 用户代理
        ExtraInfo  string               `json:"extraInfo" binding:"required"` // 操作信息
}

// UserOperationUpdateRequest 更新操作记录请求
type UserOperationUpdateRequest struct {
        UserName   *string               `json:"userName,omitempty"`   // 操作人员
        Operation  *entity.OperationType `json:"operation,omitempty"`  // 操作类型
        Module     *string               `json:"module,omitempty"`     // 操作模块
        TargetID   *uint                 `json:"targetId,omitempty"`   // 目标ID
        TargetName *string               `json:"targetName,omitempty"` // 目标名称
        IP         *string               `json:"ip,omitempty"`         // 操作IP
        UserAgent  *string               `json:"userAgent,omitempty"`  // 用户代理
        ExtraInfo  *string               `json:"extraInfo,omitempty"`  // 操作信息
}

// UserOperationResponse 操作记录响应
type UserOperationResponse struct {
        ID         uint                 `json:"id"`                   // 记录ID
        UserName   string               `json:"userName"`             // 操作人员
        Operation  entity.OperationType `json:"operation"`            // 操作类型
        Module     string               `json:"module"`               // 操作模块
        TargetID   *uint                `json:"targetId,omitempty"`   // 目标ID
        TargetName *string              `json:"targetName,omitempty"` // 目标名称
        IP         *string              `json:"ip,omitempty"`         // 操作IP
        UserAgent  *string              `json:"userAgent,omitempty"`  // 用户代理
        ExtraInfo  string               `json:"extraInfo"`            // 操作信息
        CreateTime *time.Time           `json:"createTime"`           // 操作时间
}

// UserOperationListResponse 操作记录列表响应
type UserOperationListResponse struct {
        PageResponse
        List []*UserOperationResponse `json:"list"` // 操作记录列表
}

// NewUserOperationResponseFromEntity 从实体对象构建操作记录响应
func NewUserOperationResponseFromEntity(o *entity.UserOperation) *UserOperationResponse <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;UserOperationResponse{
                ID:         o.ID,
                UserName:   o.UserName,
                Operation:  o.Operation,
                Module:     o.Module,
                TargetID:   o.TargetID,
                TargetName: o.TargetName,
                IP:         o.IP,
                UserAgent:  o.UserAgent,
                ExtraInfo:  o.ExtraInfo,
                CreateTime: o.CreateTime,
        }</span>
}

// NewUserOperationListResponseFromEntities 从实体列表构建操作记录列表响应
func NewUserOperationListResponseFromEntities(list []*entity.UserOperation, page PageResponse) *UserOperationListResponse <span class="cov0" title="0">{
        resp := &amp;UserOperationListResponse{
                PageResponse: page,
                List:         make([]*UserOperationResponse, 0, len(list)),
        }
        for _, o := range list </span><span class="cov0" title="0">{
                resp.List = append(resp.List, NewUserOperationResponseFromEntity(o))
        }</span>
        <span class="cov0" title="0">return resp</span>
}</pre>

                <pre class="file" id="file28" style="display: none">package entity

import "gorm.io/gorm"

// DeviceType 设备类型枚举
type DeviceType string

const (
        DeviceTypeWheelRobot DeviceType = "robot_wheel" // 轮式机器人
        DeviceTypeBipedRobot DeviceType = "robot_biped" // 双足机器人
)

// CompanyType 厂商类型枚举
type CompanyType string

const (
        CompanyCyborg CompanyType = "cyborg" // 赛博格
)

// Device 设备表
type Device struct {
        gorm.Model
        Type      DeviceType    `gorm:"type:text;not null;comment:设备类型"`
        Company   CompanyType   `gorm:"type:text;not null;comment:设备厂商"`
        IP        *string       `gorm:"type:text;comment:设备IP"`
        Port      int           `gorm:"comment:设备端口"`
        UserName  *string       `gorm:"type:text;comment:登录用户名"`
        Password  *string       `gorm:"type:text;comment:登录密码(RSA加密)"`
        Status    *DeviceStatus `gorm:"type:text;default:'offline';comment:设备状态"`
        ExtraInfo *string       `gorm:"type:text;comment:扩展信息(JSON)"`
}

// DeviceStatus 设备状态枚举
type DeviceStatus string

const (
        DeviceStatusOffline DeviceStatus = "offline" // 离线
        DeviceStatusOnline  DeviceStatus = "online"  // 在线
        DeviceStatusBusy    DeviceStatus = "busy"    // 忙碌
        DeviceStatusError   DeviceStatus = "error"   // 错误
)

func (Device) TableName() string <span class="cov0" title="0">{
        return "device"
}</span>
</pre>

                <pre class="file" id="file29" style="display: none">package entity

import "gorm.io/gorm"

// PCDFile 点云地图表
type PCDFile struct {
        gorm.Model
        Name      string  `gorm:"type:text;not null;comment:地图名称"`
        Area      string  `gorm:"type:text;not null;comment:区域描述"`
        Path      string  `gorm:"type:text;not null;comment:文件存储路径"`
        UserName  string  `gorm:"type:text;not null;comment:上传人员"`
        Size      int     `gorm:"comment:文件大小(字节)"`
        MinioPath *string `gorm:"type:text;comment:MinIO存储路径"`
        ExtraInfo *string `gorm:"type:text;comment:扩展信息(JSON)"`
}

func (PCDFile) TableName() string <span class="cov0" title="0">{
        return "pcd_file"
}</span>
</pre>

                <pre class="file" id="file30" style="display: none">package entity

import "gorm.io/gorm"

// SemanticMap 语义地图表
type SemanticMap struct {
        gorm.Model
        PCDFileID    uint    `gorm:"not null;comment:对应的pcd地图文件id;index"`
        PCDFile      PCDFile `gorm:"foreignKey:PCDFileID"`
        UserName     string  `gorm:"type:text;not null;comment:编辑人员"`
        SemanticInfo string  `gorm:"type:text;comment:语义信息"`
        ExtraInfo    *string `gorm:"type:text;comment:扩展信息(JSON)"`
}

func (SemanticMap) TableName() string <span class="cov0" title="0">{
        return "semantic_map"
}</span>
</pre>

                <pre class="file" id="file31" style="display: none">package entity

import "gorm.io/gorm"

// Task 任务编排表
type Task struct {
        gorm.Model
        SemanticMapID uint        `gorm:"not null;comment:对应的语义地图id;index"`
        SemanticMap   SemanticMap `gorm:"foreignKey:SemanticMapID"`
        UserName      string      `gorm:"type:text;not null;comment:编辑人员"`
        TaskInfo      string      `gorm:"type:text;comment:任务信息"`
        Status        *TaskStatus `gorm:"type:text;default:'pending';comment:任务状态"`
        ExtraInfo     *string     `gorm:"type:text;comment:扩展信息(JSON)"`
}

// TaskStatus 任务状态枚举
type TaskStatus string

const (
        TaskStatusPending   TaskStatus = "pending"   // 待执行
        TaskStatusRunning   TaskStatus = "running"   // 执行中
        TaskStatusCompleted TaskStatus = "completed" // 已完成
        TaskStatusFailed    TaskStatus = "failed"    // 失败
        TaskStatusCancelled TaskStatus = "cancelled" // 已取消
)

func (Task) TableName() string <span class="cov0" title="0">{
        return "task"
}</span>
</pre>

                <pre class="file" id="file32" style="display: none">package entity

import "gorm.io/gorm"

// RoleType 角色类型枚举
type RoleType string

const (
        RoleAdministrator RoleType = "administrator" // 超级管理员
        RoleManager       RoleType = "manager"       // 管理员
        RoleOperator      RoleType = "operator"      // 操作员
        RoleUser          RoleType = "user"          // 普通用户
)

// UserInfo 用户信息表
type UserInfo struct {
        gorm.Model
        UserName  string   `gorm:"type:text;not null;comment:用户名;uniqueIndex"`
        Password  string   `gorm:"type:text;comment:密码(DES加密)"`
        Role      RoleType `gorm:"type:text;comment:角色名称"`
        IsLocked  int      `gorm:"default:0;comment:是否锁定 0-不锁定 1-锁定"`
        ExtraInfo *string  `gorm:"type:text;comment:扩展信息(JSON)"`
}

func (UserInfo) TableName() string <span class="cov0" title="0">{
        return "user_info"
}</span>
</pre>

                <pre class="file" id="file33" style="display: none">package entity

import "time"

// OperationType 操作类型枚举
type OperationType string

const (
        OperationCreate OperationType = "create" // 创建
        OperationUpdate OperationType = "update" // 更新
        OperationDelete OperationType = "delete" // 删除
        OperationQuery  OperationType = "query"  // 查询
        OperationLogin  OperationType = "login"  // 登录
        OperationLogout OperationType = "logout" // 登出
)

// UserOperation 用户操作记录表
type UserOperation struct {
        ID         uint          `gorm:"primarykey;comment:主键ID"`
        UserName   string        `gorm:"type:text;not null;comment:操作人员"`
        Operation  OperationType `gorm:"type:text;not null;comment:操作类型"`
        Module     string        `gorm:"type:text;not null;comment:操作模块"`
        TargetID   *uint         `gorm:"comment:目标ID"`
        TargetName *string       `gorm:"type:text;comment:目标名称"`
        IP         *string       `gorm:"type:text;comment:操作IP"`
        UserAgent  *string       `gorm:"type:text;comment:用户代理"`
        ExtraInfo  string        `gorm:"type:text;not null;comment:操作信息(JSON)"`
        CreateTime *time.Time    `gorm:"type:datetime;autoCreateTime;comment:操作时间"`
}

func (UserOperation) TableName() string <span class="cov0" title="0">{
        return "user_operation"
}</span>
</pre>

                <pre class="file" id="file34" style="display: none">package service

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
)

// DeviceService 设备服务
type DeviceService struct {
        deviceDAO dao.DeviceDAO
}

func NewDeviceService(deviceDAO dao.DeviceDAO) *DeviceService <span class="cov0" title="0">{
        return &amp;DeviceService{
                deviceDAO: deviceDAO,
        }
}</span>

// CreateDevice 创建设备
func (s *DeviceService) CreateDevice(ctx context.Context, req *dto.DeviceCreateRequest) (*dto.DeviceResponse, error) <span class="cov0" title="0">{
        logger.Info("creating device in service", zap.String("type", string(req.Type)))

        // 创建设备实体
        device := &amp;entity.Device{
                Type:      req.Type,
                Company:   req.Company,
                IP:        req.IP,
                Port:      req.Port,
                UserName:  req.UserName,
                Password:  req.Password,
                Status:    &amp;[]entity.DeviceStatus{entity.DeviceStatusOffline}[0],
                ExtraInfo: req.ExtraInfo,
        }

        // 保存到数据库
        if err := s.deviceDAO.Create(ctx, device); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create device in service", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("device created successfully in service", zap.Uint("id", device.ID))
        return dto.NewDeviceResponseFromEntity(device), nil</span>
}

// UpdateDevice 更新设备
func (s *DeviceService) UpdateDevice(ctx context.Context, id uint, req *dto.DeviceUpdateRequest) error <span class="cov0" title="0">{
        logger.Info("updating device in service", zap.Uint("id", id))

        // 获取设备
        device, err := s.deviceDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find device for update", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">if device == nil </span><span class="cov0" title="0">{
                logger.Warn("device not found for update", zap.Uint("id", id))
                return errors.New("device not found")
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.Type != nil </span><span class="cov0" title="0">{
                device.Type = *req.Type
        }</span>
        <span class="cov0" title="0">if req.Company != nil </span><span class="cov0" title="0">{
                device.Company = *req.Company
        }</span>
        <span class="cov0" title="0">if req.IP != nil </span><span class="cov0" title="0">{
                device.IP = req.IP
        }</span>
        <span class="cov0" title="0">if req.Port != nil </span><span class="cov0" title="0">{
                device.Port = *req.Port
        }</span>
        <span class="cov0" title="0">if req.UserName != nil </span><span class="cov0" title="0">{
                device.UserName = req.UserName
        }</span>
        <span class="cov0" title="0">if req.Password != nil </span><span class="cov0" title="0">{
                device.Password = req.Password
        }</span>
        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                device.Status = req.Status
        }</span>
        <span class="cov0" title="0">if req.ExtraInfo != nil </span><span class="cov0" title="0">{
                device.ExtraInfo = req.ExtraInfo
        }</span>

        // 保存更新
        <span class="cov0" title="0">if err := s.deviceDAO.Update(ctx, device); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update device in service", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("device updated successfully in service", zap.Uint("id", id))
        return nil</span>
}

// DeleteDevice 删除设备
func (s *DeviceService) DeleteDevice(ctx context.Context, id uint) error <span class="cov0" title="0">{
        logger.Info("deleting device in service", zap.Uint("id", id))
        return s.deviceDAO.Delete(ctx, id)
}</span>

// GetDeviceByID 根据ID获取设备
func (s *DeviceService) GetDeviceByID(ctx context.Context, id uint) (*dto.DeviceResponse, error) <span class="cov0" title="0">{
        logger.Debug("getting device by id in service", zap.Uint("id", id))
        device, err := s.deviceDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if device == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return dto.NewDeviceResponseFromEntity(device), nil</span>
}

// ListDevices 分页获取设备列表
func (s *DeviceService) ListDevices(ctx context.Context, req dto.PageRequest) (*dto.DeviceListResponse, error) <span class="cov0" title="0">{
        logger.Debug("listing devices in service with pagination", zap.Int("page", req.Page), zap.Int("pageSize", req.PageSize))

        if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>

        <span class="cov0" title="0">offset := (req.Page - 1) * req.PageSize

        devices, total, err := s.deviceDAO.FindPage(ctx, offset, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pages := 0
        if req.PageSize &gt; 0 </span><span class="cov0" title="0">{
                pages = int((total + int64(req.PageSize) - 1) / int64(req.PageSize))
        }</span>

        <span class="cov0" title="0">page := dto.PageResponse{
                Total:    total,
                Page:     req.Page,
                PageSize: req.PageSize,
                Pages:    pages,
        }

        return dto.NewDeviceListResponseFromEntities(devices, page), nil</span>
}
</pre>

                <pre class="file" id="file35" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "time"

        "robot_scheduler/internal/config"
        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/minio_client"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
)

// PCDFileService 点云地图服务
type PCDFileService struct {
        pcdDAO dao.PCDFileDAO
}

func NewPCDFileService(pcdDAO dao.PCDFileDAO) *PCDFileService <span class="cov0" title="0">{
        return &amp;PCDFileService{
                pcdDAO: pcdDAO,
        }
}</span>

// CreatePCDFile 创建点云地图
func (s *PCDFileService) CreatePCDFile(ctx context.Context, req *dto.PCDFileCreateRequest) (*dto.PCDFileResponse, error) <span class="cov0" title="0">{
        logger.Info("creating pcd file in service", zap.String("name", req.Name))

        // 检查名称是否已存在
        existingFile, err := s.pcdDAO.FindByName(ctx, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to check pcd file name existence", zap.Error(err), zap.String("name", req.Name))
                return nil, err
        }</span>

        <span class="cov0" title="0">if existingFile != nil </span><span class="cov0" title="0">{
                logger.Warn("pcd file name already exists", zap.String("name", req.Name))
                return nil, errors.New("pcd file name already exists")
        }</span>

        // 创建点云地图实体
        <span class="cov0" title="0">file := &amp;entity.PCDFile{
                Name:      req.Name,
                Area:      req.Area,
                Path:      req.Path,
                UserName:  req.UserName,
                Size:      req.Size,
                MinioPath: req.MinioPath,
                ExtraInfo: req.ExtraInfo,
        }

        // 保存到数据库
        if err := s.pcdDAO.Create(ctx, file); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create pcd file in service", zap.Error(err), zap.String("name", req.Name))
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("pcd file created successfully in service", zap.String("name", req.Name), zap.Uint("id", file.ID))
        return dto.NewPCDFileResponseFromEntity(file), nil</span>
}

// UpdatePCDFile 更新点云地图
func (s *PCDFileService) UpdatePCDFile(ctx context.Context, id uint, req *dto.PCDFileUpdateRequest) error <span class="cov0" title="0">{
        logger.Info("updating pcd file in service", zap.Uint("id", id))

        // 获取点云地图
        file, err := s.pcdDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find pcd file for update", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">if file == nil </span><span class="cov0" title="0">{
                logger.Warn("pcd file not found for update", zap.Uint("id", id))
                return errors.New("pcd file not found")
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                file.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Area != nil </span><span class="cov0" title="0">{
                file.Area = *req.Area
        }</span>
        <span class="cov0" title="0">if req.Path != nil </span><span class="cov0" title="0">{
                file.Path = *req.Path
        }</span>
        <span class="cov0" title="0">if req.UserName != nil </span><span class="cov0" title="0">{
                file.UserName = *req.UserName
        }</span>
        <span class="cov0" title="0">if req.Size != nil </span><span class="cov0" title="0">{
                file.Size = *req.Size
        }</span>
        <span class="cov0" title="0">if req.MinioPath != nil </span><span class="cov0" title="0">{
                file.MinioPath = req.MinioPath
        }</span>
        <span class="cov0" title="0">if req.ExtraInfo != nil </span><span class="cov0" title="0">{
                file.ExtraInfo = req.ExtraInfo
        }</span>

        // 保存更新
        <span class="cov0" title="0">if err := s.pcdDAO.Update(ctx, file); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update pcd file in service", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("pcd file updated successfully in service", zap.Uint("id", id))
        return nil</span>
}

// DeletePCDFile 删除点云地图
func (s *PCDFileService) DeletePCDFile(ctx context.Context, id uint) error <span class="cov0" title="0">{
        logger.Info("deleting pcd file in service", zap.Uint("id", id))
        return s.pcdDAO.Delete(ctx, id)
}</span>

// GetPCDFileByID 根据ID获取点云地图
func (s *PCDFileService) GetPCDFileByID(ctx context.Context, id uint) (*dto.PCDFileResponse, error) <span class="cov0" title="0">{
        logger.Debug("getting pcd file by id in service", zap.Uint("id", id))
        file, err := s.pcdDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if file == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return dto.NewPCDFileResponseFromEntity(file), nil</span>
}

// ListPCDFiles 分页获取点云地图列表
func (s *PCDFileService) ListPCDFiles(ctx context.Context, req dto.PageRequest) (*dto.PCDFileListResponse, error) <span class="cov0" title="0">{
        logger.Debug("listing pcd files in service with pagination", zap.Int("page", req.Page), zap.Int("pageSize", req.PageSize))

        if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>

        <span class="cov0" title="0">offset := (req.Page - 1) * req.PageSize

        files, total, err := s.pcdDAO.FindPage(ctx, offset, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pages := 0
        if req.PageSize &gt; 0 </span><span class="cov0" title="0">{
                pages = int((total + int64(req.PageSize) - 1) / int64(req.PageSize))
        }</span>

        <span class="cov0" title="0">page := dto.PageResponse{
                Total:    total,
                Page:     req.Page,
                PageSize: req.PageSize,
                Pages:    pages,
        }

        return dto.NewPCDFileListResponseFromEntities(files, page), nil</span>
}

// GenerateUploadToken 生成点云地图上传凭证（预签名 PUT URL）
func (s *PCDFileService) GenerateUploadToken(ctx context.Context, userName string, req *dto.PCDFileUploadTokenRequest) (*dto.PCDFileUploadTokenResponse, error) <span class="cov0" title="0">{
        logger.Info("generating pcd upload token in service", zap.String("fileName", req.FileName), zap.String("userName", userName))

        cfg := config.Get()
        if cfg == nil || cfg.Minio == nil || !cfg.Minio.Enabled </span><span class="cov0" title="0">{
                logger.Error("minio not enabled in config")
                return nil, errors.New("minio is not enabled")
        }</span>

        <span class="cov0" title="0">client := minio_client.Client()
        if client == nil </span><span class="cov0" title="0">{
                logger.Error("minio client not initialized")
                return nil, errors.New("minio client not initialized")
        }</span>

        <span class="cov0" title="0">if userName == "" </span><span class="cov0" title="0">{
                userName = "unknown"
        }</span>

        <span class="cov0" title="0">objectKey := fmt.Sprintf("pcd/%s/%d_%s", userName, time.Now().Unix(), req.FileName)
        expire := 10 * time.Minute

        url, err := client.PresignedPutObject(ctx, cfg.Minio.BucketName, objectKey, expire)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to generate presigned put url", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := &amp;dto.PCDFileUploadTokenResponse{
                UploadURL: url.String(),
                Bucket:    cfg.Minio.BucketName,
                ObjectKey: objectKey,
                ExpireAt:  time.Now().Add(expire).Unix(),
        }

        logger.Info("pcd upload token generated successfully",
                zap.String("fileName", req.FileName),
                zap.String("userName", userName),
                zap.String("bucket", resp.Bucket),
                zap.String("objectKey", resp.ObjectKey),
        )

        return resp, nil</span>
}
</pre>

                <pre class="file" id="file36" style="display: none">package service

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
)

// SemanticMapService 语义地图服务
type SemanticMapService struct {
        semanticDAO dao.SemanticMapDAO
}

func NewSemanticMapService(semanticDAO dao.SemanticMapDAO) *SemanticMapService <span class="cov0" title="0">{
        return &amp;SemanticMapService{
                semanticDAO: semanticDAO,
        }
}</span>

// CreateSemanticMap 创建语义地图
func (s *SemanticMapService) CreateSemanticMap(ctx context.Context, req *dto.SemanticMapCreateRequest) (*dto.SemanticMapResponse, error) <span class="cov0" title="0">{
        logger.Info("creating semantic map in service", zap.Uint("pcdFileID", req.PCDFileID))

        // 创建语义地图实体
        semanticMap := &amp;entity.SemanticMap{
                PCDFileID:    req.PCDFileID,
                UserName:     req.UserName,
                SemanticInfo: req.SemanticInfo,
                ExtraInfo:    req.ExtraInfo,
        }

        // 保存到数据库
        if err := s.semanticDAO.Create(ctx, semanticMap); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create semantic map in service", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("semantic map created successfully in service", zap.Uint("id", semanticMap.ID))
        return dto.NewSemanticMapResponseFromEntity(semanticMap), nil</span>
}

// UpdateSemanticMap 更新语义地图
func (s *SemanticMapService) UpdateSemanticMap(ctx context.Context, id uint, req *dto.SemanticMapUpdateRequest) error <span class="cov0" title="0">{
        logger.Info("updating semantic map in service", zap.Uint("id", id))

        // 获取语义地图
        semanticMap, err := s.semanticDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find semantic map for update", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">if semanticMap == nil </span><span class="cov0" title="0">{
                logger.Warn("semantic map not found for update", zap.Uint("id", id))
                return errors.New("semantic map not found")
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.PCDFileID != nil </span><span class="cov0" title="0">{
                semanticMap.PCDFileID = *req.PCDFileID
        }</span>
        <span class="cov0" title="0">if req.UserName != nil </span><span class="cov0" title="0">{
                semanticMap.UserName = *req.UserName
        }</span>
        <span class="cov0" title="0">if req.SemanticInfo != nil </span><span class="cov0" title="0">{
                semanticMap.SemanticInfo = *req.SemanticInfo
        }</span>
        <span class="cov0" title="0">if req.ExtraInfo != nil </span><span class="cov0" title="0">{
                semanticMap.ExtraInfo = req.ExtraInfo
        }</span>

        // 保存更新
        <span class="cov0" title="0">if err := s.semanticDAO.Update(ctx, semanticMap); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update semantic map in service", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("semantic map updated successfully in service", zap.Uint("id", id))
        return nil</span>
}

// DeleteSemanticMap 删除语义地图
func (s *SemanticMapService) DeleteSemanticMap(ctx context.Context, id uint) error <span class="cov0" title="0">{
        logger.Info("deleting semantic map in service", zap.Uint("id", id))
        return s.semanticDAO.Delete(ctx, id)
}</span>

// GetSemanticMapByID 根据ID获取语义地图
func (s *SemanticMapService) GetSemanticMapByID(ctx context.Context, id uint) (*dto.SemanticMapResponse, error) <span class="cov0" title="0">{
        logger.Debug("getting semantic map by id in service", zap.Uint("id", id))
        semanticMap, err := s.semanticDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if semanticMap == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return dto.NewSemanticMapResponseFromEntity(semanticMap), nil</span>
}

// ListSemanticMaps 分页获取语义地图列表
func (s *SemanticMapService) ListSemanticMaps(ctx context.Context, req dto.PageRequest) (*dto.SemanticMapListResponse, error) <span class="cov0" title="0">{
        logger.Debug("listing semantic maps in service with pagination", zap.Int("page", req.Page), zap.Int("pageSize", req.PageSize))

        if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>

        <span class="cov0" title="0">offset := (req.Page - 1) * req.PageSize

        maps, total, err := s.semanticDAO.FindPage(ctx, offset, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pages := 0
        if req.PageSize &gt; 0 </span><span class="cov0" title="0">{
                pages = int((total + int64(req.PageSize) - 1) / int64(req.PageSize))
        }</span>

        <span class="cov0" title="0">page := dto.PageResponse{
                Total:    total,
                Page:     req.Page,
                PageSize: req.PageSize,
                Pages:    pages,
        }

        return dto.NewSemanticMapListResponseFromEntities(maps, page), nil</span>
}
</pre>

                <pre class="file" id="file37" style="display: none">package service

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
)

// TaskService 任务服务
type TaskService struct {
        taskDAO dao.TaskDAO
}

func NewTaskService(taskDAO dao.TaskDAO) *TaskService <span class="cov0" title="0">{
        return &amp;TaskService{
                taskDAO: taskDAO,
        }
}</span>

// CreateTask 创建任务
func (s *TaskService) CreateTask(ctx context.Context, req *dto.TaskCreateRequest) (*dto.TaskResponse, error) <span class="cov0" title="0">{
        logger.Info("creating task in service", zap.Uint("semanticMapID", req.SemanticMapID))

        // 创建任务实体
        task := &amp;entity.Task{
                SemanticMapID: req.SemanticMapID,
                UserName:      req.UserName,
                TaskInfo:      req.TaskInfo,
                Status:        &amp;[]entity.TaskStatus{entity.TaskStatusPending}[0],
                ExtraInfo:     req.ExtraInfo,
        }

        // 保存到数据库
        if err := s.taskDAO.Create(ctx, task); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create task in service", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("task created successfully in service", zap.Uint("id", task.ID))
        return dto.NewTaskResponseFromEntity(task), nil</span>
}

// UpdateTask 更新任务
func (s *TaskService) UpdateTask(ctx context.Context, id uint, req *dto.TaskUpdateRequest) error <span class="cov0" title="0">{
        logger.Info("updating task in service", zap.Uint("id", id))

        // 获取任务
        task, err := s.taskDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find task for update", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                logger.Warn("task not found for update", zap.Uint("id", id))
                return errors.New("task not found")
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.SemanticMapID != nil </span><span class="cov0" title="0">{
                task.SemanticMapID = *req.SemanticMapID
        }</span>
        <span class="cov0" title="0">if req.UserName != nil </span><span class="cov0" title="0">{
                task.UserName = *req.UserName
        }</span>
        <span class="cov0" title="0">if req.TaskInfo != nil </span><span class="cov0" title="0">{
                task.TaskInfo = *req.TaskInfo
        }</span>
        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                task.Status = req.Status
        }</span>
        <span class="cov0" title="0">if req.ExtraInfo != nil </span><span class="cov0" title="0">{
                task.ExtraInfo = req.ExtraInfo
        }</span>

        // 保存更新
        <span class="cov0" title="0">if err := s.taskDAO.Update(ctx, task); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update task in service", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("task updated successfully in service", zap.Uint("id", id))
        return nil</span>
}

// DeleteTask 删除任务
func (s *TaskService) DeleteTask(ctx context.Context, id uint) error <span class="cov0" title="0">{
        logger.Info("deleting task in service", zap.Uint("id", id))
        return s.taskDAO.Delete(ctx, id)
}</span>

// GetTaskByID 根据ID获取任务
func (s *TaskService) GetTaskByID(ctx context.Context, id uint) (*dto.TaskResponse, error) <span class="cov0" title="0">{
        logger.Debug("getting task by id in service", zap.Uint("id", id))
        task, err := s.taskDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if task == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return dto.NewTaskResponseFromEntity(task), nil</span>
}

// ListTasks 分页获取任务列表
func (s *TaskService) ListTasks(ctx context.Context, req dto.PageRequest) (*dto.TaskListResponse, error) <span class="cov0" title="0">{
        logger.Debug("listing tasks in service with pagination", zap.Int("page", req.Page), zap.Int("pageSize", req.PageSize))

        if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>

        <span class="cov0" title="0">offset := (req.Page - 1) * req.PageSize

        tasks, total, err := s.taskDAO.FindPage(ctx, offset, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pages := 0
        if req.PageSize &gt; 0 </span><span class="cov0" title="0">{
                pages = int((total + int64(req.PageSize) - 1) / int64(req.PageSize))
        }</span>

        <span class="cov0" title="0">page := dto.PageResponse{
                Total:    total,
                Page:     req.Page,
                PageSize: req.PageSize,
                Pages:    pages,
        }

        return dto.NewTaskListResponseFromEntities(tasks, page), nil</span>
}
</pre>

                <pre class="file" id="file38" style="display: none">package service

import (
        "context"
        "errors"

        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/model/entity"
        "robot_scheduler/internal/utils"

        "go.uber.org/zap"
)

// UserService 用户服务
type UserService struct {
        userDAO dao.UserDAO
}

func NewUserService(userDAO dao.UserDAO) *UserService <span class="cov10" title="6">{
        return &amp;UserService{
                userDAO: userDAO,
        }
}</span>

// CreateUser 创建用户
func (s *UserService) CreateUser(ctx context.Context, req *dto.UserCreateRequest, desKey string) (*dto.UserResponse, error) <span class="cov4" title="2">{
        logger.Info("creating user in service", zap.String("username", req.UserName))

        // 检查用户名是否已存在
        // existingUser, err := s.userDAO.FindByUserName(ctx, req.UserName)
        // if err != nil {
        //         logger.Error("failed to check username existence", zap.Error(err), zap.String("username", req.UserName))
        //         return nil, err
        // }

        // if existingUser != nil {
        //         logger.Warn("username already exists", zap.String("username", req.UserName))
        //         return nil, errors.New("username already exists")
        // }

        // 创建前加密密码
        encryptedPassword, err := utils.DESEncrypt(req.Password, desKey)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("failed to encrypt user password", zap.Error(err), zap.String("username", req.UserName))
                return nil, errors.New("加密用户密码失败")
        }</span>

        // 创建用户实体
        <span class="cov1" title="1">user := &amp;entity.UserInfo{
                UserName:  req.UserName,
                Password:  encryptedPassword,
                Role:      req.Role,
                IsLocked:  0,
                ExtraInfo: req.ExtraInfo,
        }

        // 保存到数据库
        if err := s.userDAO.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create user in service", zap.Error(err), zap.String("username", req.UserName))
                return nil, err
        }</span>

        <span class="cov1" title="1">logger.Info("user created successfully in service", zap.String("username", req.UserName), zap.Uint("id", user.ID))
        return dto.NewUserResponseFromEntity(user), nil</span>
}

// UpdateUser 更新用户
func (s *UserService) UpdateUser(ctx context.Context, id uint, req *dto.UserUpdateRequest, desKey string) error <span class="cov0" title="0">{
        logger.Info("updating user in service", zap.Uint("id", id))

        // 获取用户
        user, err := s.userDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find user for update", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                logger.Warn("user not found for update", zap.Uint("id", id))
                return errors.New("user not found")
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.Password != nil </span><span class="cov0" title="0">{
                encryptedPassword, err := utils.DESEncrypt(*req.Password, desKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to encrypt user password", zap.Error(err), zap.Uint("id", id))
                        return errors.New("加密用户密码失败")
                }</span>
                <span class="cov0" title="0">user.Password = encryptedPassword</span>
        }
        <span class="cov0" title="0">if req.Role != nil </span><span class="cov0" title="0">{
                user.Role = *req.Role
        }</span>
        <span class="cov0" title="0">if req.IsLocked != nil </span><span class="cov0" title="0">{
                user.IsLocked = *req.IsLocked
        }</span>
        <span class="cov0" title="0">if req.ExtraInfo != nil </span><span class="cov0" title="0">{
                user.ExtraInfo = req.ExtraInfo
        }</span>

        // 保存更新
        <span class="cov0" title="0">if err := s.userDAO.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update user in service", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("user updated successfully in service", zap.Uint("id", id))
        return nil</span>
}

// DeleteUser 删除用户
func (s *UserService) DeleteUser(ctx context.Context, id uint) error <span class="cov4" title="2">{
        logger.Info("deleting user in service", zap.Uint("id", id))
        return s.userDAO.Delete(ctx, id)
}</span>

// GetUserByID 根据ID获取用户
func (s *UserService) GetUserByID(ctx context.Context, id uint) (*dto.UserResponse, error) <span class="cov4" title="2">{
        logger.Debug("getting user by id in service", zap.Uint("id", id))
        user, err := s.userDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="2">if user == nil </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">return dto.NewUserResponseFromEntity(user), nil</span>
}

// ListUsers 分页获取用户列表
func (s *UserService) ListUsers(ctx context.Context, req dto.PageRequest) (*dto.UserListResponse, error) <span class="cov0" title="0">{
        logger.Debug("listing users in service with pagination", zap.Int("page", req.Page), zap.Int("pageSize", req.PageSize))

        // 设置默认分页参数
        if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>

        <span class="cov0" title="0">offset := (req.Page - 1) * req.PageSize

        users, total, err := s.userDAO.FindPage(ctx, offset, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pages := 0
        if req.PageSize &gt; 0 </span><span class="cov0" title="0">{
                pages = int((total + int64(req.PageSize) - 1) / int64(req.PageSize))
        }</span>

        <span class="cov0" title="0">page := dto.PageResponse{
                Total:    total,
                Page:     req.Page,
                PageSize: req.PageSize,
                Pages:    pages,
        }

        return dto.NewUserListResponseFromEntities(users, page), nil</span>
}

// FindByUserName 根据用户名查找用户
func (s *UserService) FindByUserName(ctx context.Context, userName string) (*entity.UserInfo, error) <span class="cov0" title="0">{
        logger.Debug("finding user by username in service", zap.String("username", userName))
        return s.userDAO.FindByUserName(ctx, userName)
}</span>

// Login 用户登录
func (s *UserService) Login(ctx context.Context, username, password string, desKey string, jwtSecret string, jwtExpireHours int) (*dto.LoginResponse, error) <span class="cov0" title="0">{
        logger.Info("user login attempt", zap.String("username", username))

        // 查找用户
        user, err := s.userDAO.FindByUserName(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find user for login", zap.Error(err), zap.String("username", username))
                return nil, errors.New("登录失败")
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                logger.Warn("user not found for login", zap.String("username", username))
                return nil, errors.New("用户名或密码错误")
        }</span>

        // 检查用户是否锁定
        <span class="cov0" title="0">if user.IsLocked == 1 </span><span class="cov0" title="0">{
                logger.Warn("locked user attempted login", zap.String("username", username))
                return nil, errors.New("用户已被锁定")
        }</span>

        // DES解密数据库中的密码
        <span class="cov0" title="0">decryptedPassword, err := utils.DESDecrypt(user.Password, desKey)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to decrypt password", zap.Error(err), zap.String("username", username))
                return nil, errors.New("登录失败")
        }</span>

        // 比较密码（使用常量时间比较避免时序攻击）
        <span class="cov0" title="0">if !constantTimeCompare(password, decryptedPassword) </span><span class="cov0" title="0">{
                logger.Warn("invalid password for login", zap.String("username", username))
                return nil, errors.New("用户名或密码错误")
        }</span>

        // 生成JWT token
        <span class="cov0" title="0">token, err := utils.GenerateToken(user.ID, user.UserName, user.Role, jwtSecret, jwtExpireHours)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to generate token", zap.Error(err), zap.String("username", username))
                return nil, errors.New("登录失败")
        }</span>

        // 构建响应
        <span class="cov0" title="0">response := &amp;dto.LoginResponse{
                Token: token,
                User:  dto.NewUserResponseFromEntity(user),
        }

        logger.Info("user login successful", zap.String("username", username), zap.Uint("user_id", user.ID))
        return response, nil</span>
}

// Logout 用户退出
func (s *UserService) Logout(ctx context.Context) error <span class="cov0" title="0">{
        logger.Info("user logout")
        // 简单实现，客户端删除token即可
        return nil
}</span>

// InitSuperAdmin 初始化超级管理员用户（如果不存在）
func (s *UserService) InitSuperAdmin(ctx context.Context, desKey string) error <span class="cov0" title="0">{
        const superAdminUsername = "superAdmin"
        const superAdminPassword = "superAdmin"

        logger.Info("checking superAdmin user", zap.String("username", superAdminUsername))

        // 检查用户是否已存在
        existingUser, err := s.userDAO.FindByUserName(ctx, superAdminUsername)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to check superAdmin existence", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if existingUser != nil </span><span class="cov0" title="0">{
                logger.Info("superAdmin user already exists", zap.String("username", superAdminUsername))
                return nil
        }</span>

        // 加密密码
        <span class="cov0" title="0">encryptedPassword, err := utils.DESEncrypt(superAdminPassword, desKey)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to encrypt superAdmin password", zap.Error(err))
                return err
        }</span>

        // 创建超级管理员用户
        <span class="cov0" title="0">user := &amp;entity.UserInfo{
                UserName:  superAdminUsername,
                Password:  encryptedPassword,
                Role:      entity.RoleAdministrator,
                IsLocked:  0,
                ExtraInfo: nil,
        }

        // 保存到数据库
        if err := s.userDAO.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create superAdmin user", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("superAdmin user created successfully",
                zap.String("username", superAdminUsername),
                zap.Uint("id", user.ID),
        )
        return nil</span>
}

// constantTimeCompare 常量时间比较字符串，避免时序攻击
func constantTimeCompare(a, b string) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">result := 0
        for i := 0; i &lt; len(a); i++ </span><span class="cov0" title="0">{
                result |= int(a[i]) ^ int(b[i])
        }</span>
        <span class="cov0" title="0">return result == 0</span>
}
</pre>

                <pre class="file" id="file39" style="display: none">package service

import (
        "context"
        "errors"
        dao "robot_scheduler/internal/dao/interfaces"
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/dto"
        "robot_scheduler/internal/model/entity"

        "go.uber.org/zap"
)

// UserOperationService 操作记录服务
type UserOperationService struct {
        operationDAO dao.UserOperationDAO
}

func NewUserOperationService(operationDAO dao.UserOperationDAO) *UserOperationService <span class="cov0" title="0">{
        return &amp;UserOperationService{
                operationDAO: operationDAO,
        }
}</span>

// CreateOperation 创建操作记录
func (s *UserOperationService) CreateOperation(ctx context.Context, req *dto.UserOperationCreateRequest) (*dto.UserOperationResponse, error) <span class="cov0" title="0">{
        logger.Info("creating operation record in service", zap.String("username", req.UserName))

        // 创建操作记录实体
        operation := &amp;entity.UserOperation{
                UserName:   req.UserName,
                Operation:  req.Operation,
                Module:     req.Module,
                TargetID:   req.TargetID,
                TargetName: req.TargetName,
                IP:         req.IP,
                UserAgent:  req.UserAgent,
                ExtraInfo:  req.ExtraInfo,
        }

        // 保存到数据库
        if err := s.operationDAO.Create(ctx, operation); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create operation record in service", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Info("operation record created successfully in service", zap.Uint("id", operation.ID))
        return dto.NewUserOperationResponseFromEntity(operation), nil</span>
}

// UpdateOperation 更新操作记录
func (s *UserOperationService) UpdateOperation(ctx context.Context, id uint, req *dto.UserOperationUpdateRequest) error <span class="cov0" title="0">{
        logger.Info("updating operation record in service", zap.Uint("id", id))

        // 获取操作记录
        operation, err := s.operationDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to find operation record for update", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">if operation == nil </span><span class="cov0" title="0">{
                logger.Warn("operation record not found for update", zap.Uint("id", id))
                return errors.New("operation record not found")
        }</span>

        // 更新字段
        <span class="cov0" title="0">if req.UserName != nil </span><span class="cov0" title="0">{
                operation.UserName = *req.UserName
        }</span>
        <span class="cov0" title="0">if req.Operation != nil </span><span class="cov0" title="0">{
                operation.Operation = *req.Operation
        }</span>
        <span class="cov0" title="0">if req.Module != nil </span><span class="cov0" title="0">{
                operation.Module = *req.Module
        }</span>
        <span class="cov0" title="0">if req.TargetID != nil </span><span class="cov0" title="0">{
                operation.TargetID = req.TargetID
        }</span>
        <span class="cov0" title="0">if req.TargetName != nil </span><span class="cov0" title="0">{
                operation.TargetName = req.TargetName
        }</span>
        <span class="cov0" title="0">if req.IP != nil </span><span class="cov0" title="0">{
                operation.IP = req.IP
        }</span>
        <span class="cov0" title="0">if req.UserAgent != nil </span><span class="cov0" title="0">{
                operation.UserAgent = req.UserAgent
        }</span>
        <span class="cov0" title="0">if req.ExtraInfo != nil </span><span class="cov0" title="0">{
                operation.ExtraInfo = *req.ExtraInfo
        }</span>

        // 保存更新
        <span class="cov0" title="0">if err := s.operationDAO.Update(ctx, operation); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update operation record in service", zap.Error(err), zap.Uint("id", id))
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("operation record updated successfully in service", zap.Uint("id", id))
        return nil</span>
}

// DeleteOperation 删除操作记录
func (s *UserOperationService) DeleteOperation(ctx context.Context, id uint) error <span class="cov0" title="0">{
        logger.Info("deleting operation record in service", zap.Uint("id", id))
        return s.operationDAO.Delete(ctx, id)
}</span>

// GetOperationByID 根据ID获取操作记录
func (s *UserOperationService) GetOperationByID(ctx context.Context, id uint) (*dto.UserOperationResponse, error) <span class="cov0" title="0">{
        logger.Debug("getting operation record by id in service", zap.Uint("id", id))
        operation, err := s.operationDAO.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if operation == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return dto.NewUserOperationResponseFromEntity(operation), nil</span>
}

// ListOperations 分页获取操作记录列表
func (s *UserOperationService) ListOperations(ctx context.Context, req dto.PageRequest) (*dto.UserOperationListResponse, error) <span class="cov0" title="0">{
        logger.Debug("listing operation records in service with pagination", zap.Int("page", req.Page), zap.Int("pageSize", req.PageSize))

        if req.Page &lt;= 0 </span><span class="cov0" title="0">{
                req.Page = 1
        }</span>
        <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                req.PageSize = 10
        }</span>

        <span class="cov0" title="0">offset := (req.Page - 1) * req.PageSize

        operations, total, err := s.operationDAO.FindPage(ctx, offset, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pages := 0
        if req.PageSize &gt; 0 </span><span class="cov0" title="0">{
                pages = int((total + int64(req.PageSize) - 1) / int64(req.PageSize))
        }</span>

        <span class="cov0" title="0">page := dto.PageResponse{
                Total:    total,
                Page:     req.Page,
                PageSize: req.PageSize,
                Pages:    pages,
        }

        return dto.NewUserOperationListResponseFromEntities(operations, page), nil</span>
}
</pre>

                <pre class="file" id="file40" style="display: none">package testutil

import (
        "robot_scheduler/internal/logger"
        "robot_scheduler/internal/model/entity"
        "testing"

        "go.uber.org/zap"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        gormlogger "gorm.io/gorm/logger"
)

// SetupTestDB creates an in-memory SQLite database for testing
// and automatically migrates all entities
func SetupTestDB(t *testing.T) *gorm.DB <span class="cov0" title="0">{
        t.Helper()

        // Initialize logger for tests (use nop logger to avoid file I/O)
        if logger.Logger == nil </span><span class="cov0" title="0">{
                logger.Logger = zap.NewNop()
        }</span>

        // Create in-memory SQLite database
        <span class="cov0" title="0">db, err := gorm.Open(sqlite.Open(":memory:"), &amp;gorm.Config{
                Logger: gormlogger.Default.LogMode(gormlogger.Silent),
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test database: %v", err)
        }</span>

        // Auto-migrate all entities
        <span class="cov0" title="0">err = db.AutoMigrate(
                &amp;entity.UserInfo{},
                &amp;entity.Device{},
                &amp;entity.PCDFile{},
                &amp;entity.SemanticMap{},
                &amp;entity.Task{},
                &amp;entity.UserOperation{},
        )
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to migrate test database: %v", err)
        }</span>

        <span class="cov0" title="0">return db</span>
}

// TeardownTestDB closes the database connection
func TeardownTestDB(db *gorm.DB) <span class="cov0" title="0">{
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">sqlDB.Close()</span>
}
</pre>

                <pre class="file" id="file41" style="display: none">package testutil

import (
        "robot_scheduler/internal/model/entity"
        "testing"

        "gorm.io/gorm"
)

// CreateTestUser creates a test user in the database
func CreateTestUser(t *testing.T, db *gorm.DB, username string, role entity.RoleType) *entity.UserInfo <span class="cov0" title="0">{
        t.Helper()

        user := &amp;entity.UserInfo{
                UserName: username,
                Password: "encrypted_password",
                Role:     role,
                IsLocked: 0,
        }

        if err := db.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test user: %v", err)
        }</span>

        <span class="cov0" title="0">return user</span>
}

// CreateTestDevice creates a test device in the database
func CreateTestDevice(t *testing.T, db *gorm.DB, deviceType entity.DeviceType) *entity.Device <span class="cov0" title="0">{
        t.Helper()

        status := entity.DeviceStatusOffline
        device := &amp;entity.Device{
                Type:    deviceType,
                Company: entity.CompanyCyborg,
                Port:    8080,
                Status:  &amp;status,
        }

        if err := db.Create(device).Error; err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test device: %v", err)
        }</span>

        <span class="cov0" title="0">return device</span>
}

// CreateTestPCDFile creates a test PCD file in the database
func CreateTestPCDFile(t *testing.T, db *gorm.DB, name string) *entity.PCDFile <span class="cov0" title="0">{
        t.Helper()

        pcdFile := &amp;entity.PCDFile{
                Name:     name,
                Area:     "test_area",
                Path:     "/test/path/" + name,
                UserName: "test_user",
                Size:     1024,
        }

        if err := db.Create(pcdFile).Error; err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test PCD file: %v", err)
        }</span>

        <span class="cov0" title="0">return pcdFile</span>
}

// CreateTestSemanticMap creates a test semantic map in the database
func CreateTestSemanticMap(t *testing.T, db *gorm.DB, pcdFileID uint) *entity.SemanticMap <span class="cov0" title="0">{
        t.Helper()

        semanticMap := &amp;entity.SemanticMap{
                PCDFileID:    pcdFileID,
                UserName:     "test_user",
                SemanticInfo: "test_semantic_info",
        }

        if err := db.Create(semanticMap).Error; err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test semantic map: %v", err)
        }</span>

        <span class="cov0" title="0">return semanticMap</span>
}

// CreateTestTask creates a test task in the database
func CreateTestTask(t *testing.T, db *gorm.DB, semanticMapID uint) *entity.Task <span class="cov0" title="0">{
        t.Helper()

        status := entity.TaskStatusPending
        task := &amp;entity.Task{
                SemanticMapID: semanticMapID,
                UserName:      "test_user",
                TaskInfo:      "test_task_info",
                Status:        &amp;status,
        }

        if err := db.Create(task).Error; err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test task: %v", err)
        }</span>

        <span class="cov0" title="0">return task</span>
}

// CreateTestUserOperation creates a test user operation in the database
func CreateTestUserOperation(t *testing.T, db *gorm.DB, username string, operation entity.OperationType) *entity.UserOperation <span class="cov0" title="0">{
        t.Helper()

        userOp := &amp;entity.UserOperation{
                UserName:  username,
                Operation: operation,
                Module:    "test_module",
                ExtraInfo: "{}",
        }

        if err := db.Create(userOp).Error; err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create test user operation: %v", err)
        }</span>

        <span class="cov0" title="0">return userOp</span>
}
</pre>

                <pre class="file" id="file42" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/dao/interfaces/device.go
//
// Generated by this command:
//
//        mockgen -source=internal/dao/interfaces/device.go -destination=internal/testutil/mocks/mock_device_dao.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        entity "robot_scheduler/internal/model/entity"

        gomock "go.uber.org/mock/gomock"
)

// MockDeviceDAO is a mock of DeviceDAO interface.
type MockDeviceDAO struct {
        ctrl     *gomock.Controller
        recorder *MockDeviceDAOMockRecorder
        isgomock struct{}
}

// MockDeviceDAOMockRecorder is the mock recorder for MockDeviceDAO.
type MockDeviceDAOMockRecorder struct {
        mock *MockDeviceDAO
}

// NewMockDeviceDAO creates a new mock instance.
func NewMockDeviceDAO(ctrl *gomock.Controller) *MockDeviceDAO <span class="cov0" title="0">{
        mock := &amp;MockDeviceDAO{ctrl: ctrl}
        mock.recorder = &amp;MockDeviceDAOMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeviceDAO) EXPECT() *MockDeviceDAOMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockDeviceDAO) Create(ctx context.Context, device *entity.Device) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, device)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockDeviceDAOMockRecorder) Create(ctx, device any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockDeviceDAO)(nil).Create), ctx, device)
}</span>

// Delete mocks base method.
func (m *MockDeviceDAO) Delete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockDeviceDAOMockRecorder) Delete(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockDeviceDAO)(nil).Delete), ctx, id)
}</span>

// FindAll mocks base method.
func (m *MockDeviceDAO) FindAll(ctx context.Context) ([]*entity.Device, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll", ctx)
        ret0, _ := ret[0].([]*entity.Device)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockDeviceDAOMockRecorder) FindAll(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockDeviceDAO)(nil).FindAll), ctx)
}</span>

// FindByID mocks base method.
func (m *MockDeviceDAO) FindByID(ctx context.Context, id uint) (*entity.Device, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", ctx, id)
        ret0, _ := ret[0].(*entity.Device)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockDeviceDAOMockRecorder) FindByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockDeviceDAO)(nil).FindByID), ctx, id)
}</span>

// FindPage mocks base method.
func (m *MockDeviceDAO) FindPage(ctx context.Context, offset, limit int) ([]*entity.Device, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPage", ctx, offset, limit)
        ret0, _ := ret[0].([]*entity.Device)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FindPage indicates an expected call of FindPage.
func (mr *MockDeviceDAOMockRecorder) FindPage(ctx, offset, limit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPage", reflect.TypeOf((*MockDeviceDAO)(nil).FindPage), ctx, offset, limit)
}</span>

// Update mocks base method.
func (m *MockDeviceDAO) Update(ctx context.Context, device *entity.Device) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, device)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockDeviceDAOMockRecorder) Update(ctx, device any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockDeviceDAO)(nil).Update), ctx, device)
}</span>
</pre>

                <pre class="file" id="file43" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/dao/interfaces/pcd_dao.go
//
// Generated by this command:
//
//        mockgen -source=internal/dao/interfaces/pcd_dao.go -destination=internal/testutil/mocks/mock_pcd_dao.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        entity "robot_scheduler/internal/model/entity"

        gomock "go.uber.org/mock/gomock"
)

// MockPCDFileDAO is a mock of PCDFileDAO interface.
type MockPCDFileDAO struct {
        ctrl     *gomock.Controller
        recorder *MockPCDFileDAOMockRecorder
        isgomock struct{}
}

// MockPCDFileDAOMockRecorder is the mock recorder for MockPCDFileDAO.
type MockPCDFileDAOMockRecorder struct {
        mock *MockPCDFileDAO
}

// NewMockPCDFileDAO creates a new mock instance.
func NewMockPCDFileDAO(ctrl *gomock.Controller) *MockPCDFileDAO <span class="cov0" title="0">{
        mock := &amp;MockPCDFileDAO{ctrl: ctrl}
        mock.recorder = &amp;MockPCDFileDAOMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPCDFileDAO) EXPECT() *MockPCDFileDAOMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockPCDFileDAO) Create(ctx context.Context, file *entity.PCDFile) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, file)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockPCDFileDAOMockRecorder) Create(ctx, file any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPCDFileDAO)(nil).Create), ctx, file)
}</span>

// Delete mocks base method.
func (m *MockPCDFileDAO) Delete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPCDFileDAOMockRecorder) Delete(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPCDFileDAO)(nil).Delete), ctx, id)
}</span>

// FindAll mocks base method.
func (m *MockPCDFileDAO) FindAll(ctx context.Context) ([]*entity.PCDFile, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll", ctx)
        ret0, _ := ret[0].([]*entity.PCDFile)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockPCDFileDAOMockRecorder) FindAll(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockPCDFileDAO)(nil).FindAll), ctx)
}</span>

// FindByID mocks base method.
func (m *MockPCDFileDAO) FindByID(ctx context.Context, id uint) (*entity.PCDFile, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", ctx, id)
        ret0, _ := ret[0].(*entity.PCDFile)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockPCDFileDAOMockRecorder) FindByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockPCDFileDAO)(nil).FindByID), ctx, id)
}</span>

// FindByName mocks base method.
func (m *MockPCDFileDAO) FindByName(ctx context.Context, name string) (*entity.PCDFile, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByName", ctx, name)
        ret0, _ := ret[0].(*entity.PCDFile)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByName indicates an expected call of FindByName.
func (mr *MockPCDFileDAOMockRecorder) FindByName(ctx, name any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByName", reflect.TypeOf((*MockPCDFileDAO)(nil).FindByName), ctx, name)
}</span>

// FindPage mocks base method.
func (m *MockPCDFileDAO) FindPage(ctx context.Context, offset, limit int) ([]*entity.PCDFile, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPage", ctx, offset, limit)
        ret0, _ := ret[0].([]*entity.PCDFile)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FindPage indicates an expected call of FindPage.
func (mr *MockPCDFileDAOMockRecorder) FindPage(ctx, offset, limit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPage", reflect.TypeOf((*MockPCDFileDAO)(nil).FindPage), ctx, offset, limit)
}</span>

// Update mocks base method.
func (m *MockPCDFileDAO) Update(ctx context.Context, file *entity.PCDFile) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, file)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockPCDFileDAOMockRecorder) Update(ctx, file any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPCDFileDAO)(nil).Update), ctx, file)
}</span>
</pre>

                <pre class="file" id="file44" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/dao/interfaces/semantic.go
//
// Generated by this command:
//
//        mockgen -source=internal/dao/interfaces/semantic.go -destination=internal/testutil/mocks/mock_semantic_dao.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        entity "robot_scheduler/internal/model/entity"

        gomock "go.uber.org/mock/gomock"
)

// MockSemanticMapDAO is a mock of SemanticMapDAO interface.
type MockSemanticMapDAO struct {
        ctrl     *gomock.Controller
        recorder *MockSemanticMapDAOMockRecorder
        isgomock struct{}
}

// MockSemanticMapDAOMockRecorder is the mock recorder for MockSemanticMapDAO.
type MockSemanticMapDAOMockRecorder struct {
        mock *MockSemanticMapDAO
}

// NewMockSemanticMapDAO creates a new mock instance.
func NewMockSemanticMapDAO(ctrl *gomock.Controller) *MockSemanticMapDAO <span class="cov0" title="0">{
        mock := &amp;MockSemanticMapDAO{ctrl: ctrl}
        mock.recorder = &amp;MockSemanticMapDAOMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSemanticMapDAO) EXPECT() *MockSemanticMapDAOMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockSemanticMapDAO) Create(ctx context.Context, semanticMap *entity.SemanticMap) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, semanticMap)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockSemanticMapDAOMockRecorder) Create(ctx, semanticMap any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockSemanticMapDAO)(nil).Create), ctx, semanticMap)
}</span>

// Delete mocks base method.
func (m *MockSemanticMapDAO) Delete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockSemanticMapDAOMockRecorder) Delete(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockSemanticMapDAO)(nil).Delete), ctx, id)
}</span>

// FindAll mocks base method.
func (m *MockSemanticMapDAO) FindAll(ctx context.Context) ([]*entity.SemanticMap, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll", ctx)
        ret0, _ := ret[0].([]*entity.SemanticMap)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockSemanticMapDAOMockRecorder) FindAll(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockSemanticMapDAO)(nil).FindAll), ctx)
}</span>

// FindByID mocks base method.
func (m *MockSemanticMapDAO) FindByID(ctx context.Context, id uint) (*entity.SemanticMap, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", ctx, id)
        ret0, _ := ret[0].(*entity.SemanticMap)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockSemanticMapDAOMockRecorder) FindByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockSemanticMapDAO)(nil).FindByID), ctx, id)
}</span>

// FindPage mocks base method.
func (m *MockSemanticMapDAO) FindPage(ctx context.Context, offset, limit int) ([]*entity.SemanticMap, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPage", ctx, offset, limit)
        ret0, _ := ret[0].([]*entity.SemanticMap)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FindPage indicates an expected call of FindPage.
func (mr *MockSemanticMapDAOMockRecorder) FindPage(ctx, offset, limit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPage", reflect.TypeOf((*MockSemanticMapDAO)(nil).FindPage), ctx, offset, limit)
}</span>

// Update mocks base method.
func (m *MockSemanticMapDAO) Update(ctx context.Context, semanticMap *entity.SemanticMap) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, semanticMap)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockSemanticMapDAOMockRecorder) Update(ctx, semanticMap any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockSemanticMapDAO)(nil).Update), ctx, semanticMap)
}</span>
</pre>

                <pre class="file" id="file45" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/dao/interfaces/task.go
//
// Generated by this command:
//
//        mockgen -source=internal/dao/interfaces/task.go -destination=internal/testutil/mocks/mock_task_dao.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        entity "robot_scheduler/internal/model/entity"

        gomock "go.uber.org/mock/gomock"
)

// MockTaskDAO is a mock of TaskDAO interface.
type MockTaskDAO struct {
        ctrl     *gomock.Controller
        recorder *MockTaskDAOMockRecorder
        isgomock struct{}
}

// MockTaskDAOMockRecorder is the mock recorder for MockTaskDAO.
type MockTaskDAOMockRecorder struct {
        mock *MockTaskDAO
}

// NewMockTaskDAO creates a new mock instance.
func NewMockTaskDAO(ctrl *gomock.Controller) *MockTaskDAO <span class="cov0" title="0">{
        mock := &amp;MockTaskDAO{ctrl: ctrl}
        mock.recorder = &amp;MockTaskDAOMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskDAO) EXPECT() *MockTaskDAOMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockTaskDAO) Create(ctx context.Context, task *entity.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, task)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockTaskDAOMockRecorder) Create(ctx, task any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTaskDAO)(nil).Create), ctx, task)
}</span>

// Delete mocks base method.
func (m *MockTaskDAO) Delete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockTaskDAOMockRecorder) Delete(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTaskDAO)(nil).Delete), ctx, id)
}</span>

// FindAll mocks base method.
func (m *MockTaskDAO) FindAll(ctx context.Context) ([]*entity.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll", ctx)
        ret0, _ := ret[0].([]*entity.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockTaskDAOMockRecorder) FindAll(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockTaskDAO)(nil).FindAll), ctx)
}</span>

// FindByID mocks base method.
func (m *MockTaskDAO) FindByID(ctx context.Context, id uint) (*entity.Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", ctx, id)
        ret0, _ := ret[0].(*entity.Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockTaskDAOMockRecorder) FindByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockTaskDAO)(nil).FindByID), ctx, id)
}</span>

// FindPage mocks base method.
func (m *MockTaskDAO) FindPage(ctx context.Context, offset, limit int) ([]*entity.Task, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPage", ctx, offset, limit)
        ret0, _ := ret[0].([]*entity.Task)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FindPage indicates an expected call of FindPage.
func (mr *MockTaskDAOMockRecorder) FindPage(ctx, offset, limit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPage", reflect.TypeOf((*MockTaskDAO)(nil).FindPage), ctx, offset, limit)
}</span>

// Update mocks base method.
func (m *MockTaskDAO) Update(ctx context.Context, task *entity.Task) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, task)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockTaskDAOMockRecorder) Update(ctx, task any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTaskDAO)(nil).Update), ctx, task)
}</span>
</pre>

                <pre class="file" id="file46" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/dao/interfaces/user_dao.go
//
// Generated by this command:
//
//        mockgen -source=internal/dao/interfaces/user_dao.go -destination=internal/testutil/mocks/mock_user_dao.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        entity "robot_scheduler/internal/model/entity"

        gomock "go.uber.org/mock/gomock"
)

// MockUserDAO is a mock of UserDAO interface.
type MockUserDAO struct {
        ctrl     *gomock.Controller
        recorder *MockUserDAOMockRecorder
        isgomock struct{}
}

// MockUserDAOMockRecorder is the mock recorder for MockUserDAO.
type MockUserDAOMockRecorder struct {
        mock *MockUserDAO
}

// NewMockUserDAO creates a new mock instance.
func NewMockUserDAO(ctrl *gomock.Controller) *MockUserDAO <span class="cov0" title="0">{
        mock := &amp;MockUserDAO{ctrl: ctrl}
        mock.recorder = &amp;MockUserDAOMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserDAO) EXPECT() *MockUserDAOMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserDAO) Create(ctx context.Context, user *entity.UserInfo) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserDAOMockRecorder) Create(ctx, user any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserDAO)(nil).Create), ctx, user)
}</span>

// Delete mocks base method.
func (m *MockUserDAO) Delete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserDAOMockRecorder) Delete(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserDAO)(nil).Delete), ctx, id)
}</span>

// FindAll mocks base method.
func (m *MockUserDAO) FindAll(ctx context.Context) ([]*entity.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll", ctx)
        ret0, _ := ret[0].([]*entity.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockUserDAOMockRecorder) FindAll(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockUserDAO)(nil).FindAll), ctx)
}</span>

// FindByID mocks base method.
func (m *MockUserDAO) FindByID(ctx context.Context, id uint) (*entity.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", ctx, id)
        ret0, _ := ret[0].(*entity.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockUserDAOMockRecorder) FindByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockUserDAO)(nil).FindByID), ctx, id)
}</span>

// FindByUserName mocks base method.
func (m *MockUserDAO) FindByUserName(ctx context.Context, userName string) (*entity.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByUserName", ctx, userName)
        ret0, _ := ret[0].(*entity.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByUserName indicates an expected call of FindByUserName.
func (mr *MockUserDAOMockRecorder) FindByUserName(ctx, userName any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserName", reflect.TypeOf((*MockUserDAO)(nil).FindByUserName), ctx, userName)
}</span>

// FindPage mocks base method.
func (m *MockUserDAO) FindPage(ctx context.Context, offset, limit int) ([]*entity.UserInfo, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPage", ctx, offset, limit)
        ret0, _ := ret[0].([]*entity.UserInfo)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FindPage indicates an expected call of FindPage.
func (mr *MockUserDAOMockRecorder) FindPage(ctx, offset, limit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPage", reflect.TypeOf((*MockUserDAO)(nil).FindPage), ctx, offset, limit)
}</span>

// Update mocks base method.
func (m *MockUserDAO) Update(ctx context.Context, user *entity.UserInfo) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserDAOMockRecorder) Update(ctx, user any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserDAO)(nil).Update), ctx, user)
}</span>
</pre>

                <pre class="file" id="file47" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/dao/interfaces/user_operation.go
//
// Generated by this command:
//
//        mockgen -source=internal/dao/interfaces/user_operation.go -destination=internal/testutil/mocks/mock_user_operation_dao.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"
        entity "robot_scheduler/internal/model/entity"

        gomock "go.uber.org/mock/gomock"
)

// MockUserOperationDAO is a mock of UserOperationDAO interface.
type MockUserOperationDAO struct {
        ctrl     *gomock.Controller
        recorder *MockUserOperationDAOMockRecorder
        isgomock struct{}
}

// MockUserOperationDAOMockRecorder is the mock recorder for MockUserOperationDAO.
type MockUserOperationDAOMockRecorder struct {
        mock *MockUserOperationDAO
}

// NewMockUserOperationDAO creates a new mock instance.
func NewMockUserOperationDAO(ctrl *gomock.Controller) *MockUserOperationDAO <span class="cov0" title="0">{
        mock := &amp;MockUserOperationDAO{ctrl: ctrl}
        mock.recorder = &amp;MockUserOperationDAOMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserOperationDAO) EXPECT() *MockUserOperationDAOMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserOperationDAO) Create(ctx context.Context, operation *entity.UserOperation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, operation)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserOperationDAOMockRecorder) Create(ctx, operation any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserOperationDAO)(nil).Create), ctx, operation)
}</span>

// Delete mocks base method.
func (m *MockUserOperationDAO) Delete(ctx context.Context, id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserOperationDAOMockRecorder) Delete(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserOperationDAO)(nil).Delete), ctx, id)
}</span>

// FindAll mocks base method.
func (m *MockUserOperationDAO) FindAll(ctx context.Context) ([]*entity.UserOperation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll", ctx)
        ret0, _ := ret[0].([]*entity.UserOperation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockUserOperationDAOMockRecorder) FindAll(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockUserOperationDAO)(nil).FindAll), ctx)
}</span>

// FindByID mocks base method.
func (m *MockUserOperationDAO) FindByID(ctx context.Context, id uint) (*entity.UserOperation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", ctx, id)
        ret0, _ := ret[0].(*entity.UserOperation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockUserOperationDAOMockRecorder) FindByID(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockUserOperationDAO)(nil).FindByID), ctx, id)
}</span>

// FindPage mocks base method.
func (m *MockUserOperationDAO) FindPage(ctx context.Context, offset, limit int) ([]*entity.UserOperation, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPage", ctx, offset, limit)
        ret0, _ := ret[0].([]*entity.UserOperation)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FindPage indicates an expected call of FindPage.
func (mr *MockUserOperationDAOMockRecorder) FindPage(ctx, offset, limit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPage", reflect.TypeOf((*MockUserOperationDAO)(nil).FindPage), ctx, offset, limit)
}</span>

// Update mocks base method.
func (m *MockUserOperationDAO) Update(ctx context.Context, operation *entity.UserOperation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, operation)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserOperationDAOMockRecorder) Update(ctx, operation any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserOperationDAO)(nil).Update), ctx, operation)
}</span>
</pre>

                <pre class="file" id="file48" style="display: none">package utils

import (
        "crypto/cipher"
        "crypto/des"
        "encoding/base64"
        "errors"
)

// DESEncrypt DES加密
func DESEncrypt(plaintext, key string) (string, error) <span class="cov5" title="9">{
        // 确保密钥长度为8字节
        keyBytes := []byte(key)
        if len(keyBytes) != 8 </span><span class="cov3" title="3">{
                return "", errors.New("DES key must be 8 bytes")
        }</span>

        // 创建DES cipher
        <span class="cov5" title="6">block, err := des.NewCipher(keyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // PKCS5Padding填充
        <span class="cov5" title="6">plaintextBytes := []byte(plaintext)
        plaintextBytes = pkcs5Padding(plaintextBytes, block.BlockSize())

        // 使用CBC模式
        iv := keyBytes // 使用密钥作为IV（实际生产环境应使用随机IV）
        mode := cipher.NewCBCEncrypter(block, iv)

        // 加密
        ciphertext := make([]byte, len(plaintextBytes))
        mode.CryptBlocks(ciphertext, plaintextBytes)

        // Base64编码
        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// DESDecrypt DES解密
func DESDecrypt(ciphertext, key string) (string, error) <span class="cov5" title="7">{
        // 确保密钥长度为8字节
        keyBytes := []byte(key)
        if len(keyBytes) != 8 </span><span class="cov1" title="1">{
                return "", errors.New("DES key must be 8 bytes")
        }</span>

        // Base64解码
        <span class="cov5" title="6">ciphertextBytes, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        // 创建DES cipher
        <span class="cov4" title="5">block, err := des.NewCipher(keyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 使用CBC模式
        <span class="cov4" title="5">iv := keyBytes // 使用密钥作为IV（实际生产环境应使用随机IV）
        mode := cipher.NewCBCDecrypter(block, iv)

        // 解密
        plaintext := make([]byte, len(ciphertextBytes))
        mode.CryptBlocks(plaintext, ciphertextBytes)

        // 去除PKCS5Padding填充
        plaintext = pkcs5UnPadding(plaintext)

        return string(plaintext), nil</span>
}

// pkcs5Padding PKCS5填充
func pkcs5Padding(data []byte, blockSize int) []byte <span class="cov5" title="9">{
        padding := blockSize - len(data)%blockSize
        padtext := make([]byte, padding)
        for i := range padtext </span><span class="cov10" title="56">{
                padtext[i] = byte(padding)
        }</span>
        <span class="cov5" title="9">return append(data, padtext...)</span>
}

// pkcs5UnPadding 去除PKCS5填充
func pkcs5UnPadding(data []byte) []byte <span class="cov5" title="8">{
        length := len(data)
        if length == 0 </span><span class="cov1" title="1">{
                return data
        }</span>
        <span class="cov5" title="7">unpadding := int(data[length-1])
        if unpadding &gt; length </span><span class="cov0" title="0">{
                return data
        }</span>
        <span class="cov5" title="7">return data[:(length - unpadding)]</span>
}
</pre>

                <pre class="file" id="file49" style="display: none">package utils

import (
        "errors"
        "robot_scheduler/internal/model/entity"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// Claims JWT声明结构
type Claims struct {
        UserID   uint            `json:"user_id"`
        UserName string          `json:"user_name"`
        Role     entity.RoleType `json:"role"`
        jwt.RegisteredClaims
}

// GenerateToken 生成JWT token
func GenerateToken(userID uint, username string, role entity.RoleType, secret string, expireHours int) (string, error) <span class="cov7" title="3">{
        // 设置过期时间
        expirationTime := time.Now().Add(time.Duration(expireHours) * time.Hour)

        // 创建Claims
        claims := &amp;Claims{
                UserID:   userID,
                UserName: username,
                Role:     role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
        }

        // 创建token
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        // 签名token
        tokenString, err := token.SignedString([]byte(secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov7" title="3">return tokenString, nil</span>
}

// ValidateToken 验证并解析JWT token
func ValidateToken(tokenString, secret string) (*Claims, error) <span class="cov10" title="5">{
        // 解析token
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov7" title="3">{
                // 验证签名方法
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid signing method")
                }</span>
                <span class="cov7" title="3">return []byte(secret), nil</span>
        })

        <span class="cov10" title="5">if err != nil </span><span class="cov8" title="4">{
                return nil, err
        }</span>

        // 验证claims
        <span class="cov1" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov1" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}
</pre>

                <pre class="file" id="file50" style="display: none">package utils

import "robot_scheduler/internal/model/entity"

// 权限常量定义
const (
        PermissionUserManage    = "user:manage"    // 用户管理
        PermissionUserView      = "user:view"      // 用户查看
        PermissionMapManage     = "map:manage"     // 地图管理（创建/编辑/删除）
        PermissionMapView       = "map:view"       // 地图查看
        PermissionTaskManage    = "task:manage"    // 任务管理
        PermissionTaskView      = "task:view"      // 任务查看
        PermissionDeviceManage  = "device:manage"  // 设备管理（创建/编辑/删除）
        PermissionDeviceView    = "device:view"    // 设备查看
        PermissionOperationView = "operation:view" // 操作记录查看
)

// GetRolePermissions 获取角色对应的权限列表
func GetRolePermissions(role entity.RoleType) []string <span class="cov8" title="14">{
        switch role </span>{
        case entity.RoleAdministrator:<span class="cov4" title="3">
                // 超级管理员：所有权限
                return []string{
                        PermissionUserManage,
                        PermissionUserView,
                        PermissionMapManage,
                        PermissionMapView,
                        PermissionTaskManage,
                        PermissionTaskView,
                        PermissionDeviceManage,
                        PermissionDeviceView,
                        PermissionOperationView,
                }</span>
        case entity.RoleManager:<span class="cov4" title="3">
                // 管理员：除用户管理外的所有权限
                return []string{
                        PermissionUserView,
                        PermissionMapManage,
                        PermissionMapView,
                        PermissionTaskManage,
                        PermissionTaskView,
                        PermissionDeviceManage,
                        PermissionDeviceView,
                        PermissionOperationView,
                }</span>
        case entity.RoleOperator:<span class="cov1" title="1">
                // 操作员：地图查看、任务管理、设备管理、操作记录查看
                return []string{
                        PermissionUserView,
                        PermissionMapView,
                        PermissionTaskManage,
                        PermissionTaskView,
                        PermissionDeviceManage,
                        PermissionDeviceView,
                        PermissionOperationView,
                }</span>
        case entity.RoleUser:<span class="cov6" title="6">
                // 普通用户：仅查看
                return []string{
                        PermissionUserView,
                        PermissionDeviceView,
                        PermissionTaskView,
                        PermissionOperationView,
                        PermissionMapView,
                }</span>
        default:<span class="cov1" title="1">
                return []string{}</span>
        }
}

// HasPermission 检查角色是否拥有指定权限
func HasPermission(role entity.RoleType, permission string) bool <span class="cov5" title="4">{
        permissions := GetRolePermissions(role)
        for _, p := range permissions </span><span class="cov8" title="15">{
                if p == permission </span><span class="cov3" title="2">{
                        return true
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

// HasAnyPermission 检查角色是否拥有任意一个指定权限
func HasAnyPermission(role entity.RoleType, requiredPermissions ...string) bool <span class="cov4" title="3">{
        if len(requiredPermissions) == 0 </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov3" title="2">rolePermissions := GetRolePermissions(role)
        permissionMap := make(map[string]bool)
        for _, p := range rolePermissions </span><span class="cov7" title="10">{
                permissionMap[p] = true
        }</span>

        <span class="cov3" title="2">for _, required := range requiredPermissions </span><span class="cov4" title="3">{
                if permissionMap[required] </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

// HasAllPermissions 检查角色是否拥有所有指定权限
func HasAllPermissions(role entity.RoleType, requiredPermissions ...string) bool <span class="cov5" title="4">{
        if len(requiredPermissions) == 0 </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov4" title="3">rolePermissions := GetRolePermissions(role)
        permissionMap := make(map[string]bool)
        for _, p := range rolePermissions </span><span class="cov10" title="22">{
                permissionMap[p] = true
        }</span>

        <span class="cov4" title="3">for _, required := range requiredPermissions </span><span class="cov6" title="6">{
                if !permissionMap[required] </span><span class="cov3" title="2">{
                        return false
                }</span>
        }

        <span class="cov1" title="1">return true</span>
}
</pre>

        </div>
</body>
<script>
        (function () {
                var files = document.getElementById('files');
                var visible;
                files.addEventListener('change', onChange, false);
                function select(part) {
                        if (visible)
                                visible.style.display = 'none';
                        visible = document.getElementById(part);
                        if (!visible)
                                return;
                        files.value = part;
                        visible.style.display = 'block';
                        location.hash = part;
                }
                function onChange() {
                        select(files.value);
                        window.scrollTo(0, 0);
                }
                if (location.hash != "") {
                        select(location.hash.substr(1));
                }
                if (!visible) {
                        select("file0");
                }
        })();
</script>

</html>